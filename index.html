<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arona-3D three js | by Bao-arona</title>
    <style>
        body {
            margin: 0;
            overflow-x: hidden;
            overflow-y: auto; /* Cho ph√©p cu·ªôn d·ªçc */
            background-color: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
            position: fixed; /* C·ªë ƒë·ªãnh canvas n·ªÅn */
            top: 0; left: 0; z-index: -1;
            touch-action: none; /* NgƒÉn cu·ªôn trang tr√™n mobile khi ch·∫°m v√†o canvas */
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        .quality-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 5px;
            z-index: 1000;
        }
        .quality-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 12px;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.3s;
        }
        .quality-btn:hover, .quality-btn.active {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 15px #00ffff;
        }
        #transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            opacity: 0;
            pointer-events: none;
            z-index: 2000;
            transition: opacity 0.5s ease-in-out;
        }
        #warp-btn {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff0040;
            color: #ff0040;
            padding: 15px 40px;
            font-size: 20px;
            font-family: monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
            letter-spacing: 4px;
        }
        #warp-btn:hover, #warp-btn.active {
            background: #ff0040;
            color: #000;
            box-shadow: 0 0 30px #ff0040;
        }
        #audio-btn {
            position: absolute;
            bottom: 30px;
            right: 140px; /* D·ªùi sang tr√°i ƒë·ªÉ nh∆∞·ªùng ch·ªó cho AI Widget */
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 15px 20px;
            font-size: 16px;
            font-family: monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
        }
        #audio-btn:hover, #audio-btn.active {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 30px #00ff00;
        }
        #director-btn {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(255, 165, 0, 0.2);
            border: 2px solid #ffa500;
            color: #ffa500;
            padding: 10px 15px;
            font-size: 14px;
            font-family: monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1600; /* Cao h∆°n Cinematic Bars ƒë·ªÉ lu√¥n b·∫•m ƒë∆∞·ª£c */
        }
        #director-btn:hover, #director-btn.active {
            background: #ffa500;
            color: #000;
            box-shadow: 0 0 20px #ffa500;
        }
        
        #benchmark-btn {
            position: absolute;
            top: 130px;
            left: 20px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 15px;
            font-size: 14px;
            font-family: monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
        }
        #benchmark-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff;
        }
        #benchmark-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 40px;
            color: #00ffff;
            font-family: monospace;
            text-align: center;
            z-index: 3000;
            display: none;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
            min-width: 300px;
        }
        
        /* --- Cinematic Bars --- */
        .cinematic-bar {
            position: fixed;
            left: 0;
            width: 100%;
            height: 0;
            background-color: black;
            z-index: 1500; /* Che c√°c n√∫t kh√°c nh∆∞ng n·∫±m d∆∞·ªõi transition overlay */
            transition: height 0.8s ease-in-out;
        }
        #cinematic-bar-top { top: 0; }
        #cinematic-bar-bottom { bottom: 0; }

        /* --- Mobile Optimization --- */
        @media (max-width: 768px) {
            .quality-controls {
                top: 10px;
                right: 5px;
                left: 5px;
                justify-content: center;
                flex-wrap: wrap;
                gap: 4px;
            }
            .quality-btn {
                padding: 6px 8px;
                font-size: 11px;
                flex: 1 0 auto; /* T·ª± ƒë·ªông co gi√£n */
                text-align: center;
            }
            #warp-btn {
                bottom: 50px; /* N√¢ng l√™n ƒë·ªÉ tr√°nh thanh ƒëi·ªÅu h∆∞·ªõng iOS/Android */
                width: 80%;
                font-size: 16px;
                padding: 12px 0;
            }
            #audio-btn {
                bottom: 110px; /* N·∫±m tr√™n n√∫t Warp */
                right: 50%;
                transform: translateX(50%);
                width: 80%;
                text-align: center;
            }
            #director-btn {
                top: auto;
                bottom: 170px; /* X·∫øp ch·ªìng l√™n tr√™n audio btn */
                right: 50%;
                transform: translateX(50%);
                width: 80%;
                text-align: center;
                left: auto;
            }
            #benchmark-btn {
                top: auto;
                bottom: 230px; /* X·∫øp ch·ªìng l√™n tr√™n director btn */
                left: 50%;
                transform: translateX(-50%);
                width: 80%;
                text-align: center;
            }
        }

        /* --- Landing Screen & CPU Test --- */
        #landing-screen {
            position: relative; /* Thay ƒë·ªïi t·ª´ fixed sang relative ƒë·ªÉ cu·ªôn ƒë∆∞·ª£c */
            width: 100%; 
            min-height: 100vh; /* Chi·ªÅu cao t·ªëi thi·ªÉu b·∫±ng m√†n h√¨nh */
            background: radial-gradient(circle at center, #111 0%, #000 100%);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 50px;
            transition: opacity 1s ease-in-out, transform 1s ease-in;
            overflow: hidden; /* Gi·ªØ c√°c h·∫°t particle b√™n trong */
        }
        #landing-screen::before {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            mask-image: radial-gradient(circle at center, black 30%, transparent 80%);
            animation: gridScroll 20s linear infinite;
        }
        @keyframes gridScroll {
            0% { background-position: 0 0; }
            100% { background-position: 40px 40px; }
        }
        .landing-title {
            font-size: 4vw;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px #00ffff;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            position: relative;
            z-index: 2;
            text-align: center;
            animation: titlePulse 3s infinite alternate;
            /* animation: titlePulse 3s infinite alternate; */ /* Thay b·∫±ng Glitch Effect */
        }
        @keyframes titlePulse {
            0% { text-shadow: 0 0 20px #00ffff; opacity: 0.9; }
            100% { text-shadow: 0 0 40px #00ffff, 0 0 10px #fff; opacity: 1; }
        }
        .landing-title::before, .landing-title::after {
            content: attr(data-text);
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000; /* N·ªÅn ƒëen ƒë·ªÉ che text g·ªëc khi glitch */
            opacity: 0.8;
        }
        .landing-title::before {
            left: 2px;
            text-shadow: -2px 0 #ff00c1;
            clip-path: inset(44% 0 61% 0);
            animation: glitch-anim-1 2s infinite linear alternate-reverse;
            background: transparent;
        }
        .landing-title::after {
            left: -2px;
            text-shadow: -2px 0 #00fff9;
            clip-path: inset(50% 0 30% 0);
            animation: glitch-anim-2 2s infinite linear alternate-reverse;
            background: transparent;
        }
        @keyframes glitch-anim-1 {
            0% { clip-path: inset(20% 0 80% 0); transform: translate(-2px, 1px); }
            20% { clip-path: inset(60% 0 10% 0); transform: translate(2px, -1px); }
            40% { clip-path: inset(40% 0 30% 0); transform: translate(-2px, 2px); }
            60% { clip-path: inset(80% 0 5% 0); transform: translate(2px, -2px); }
            80% { clip-path: inset(10% 0 70% 0); transform: translate(-1px, 1px); }
            100% { clip-path: inset(30% 0 20% 0); transform: translate(1px, -1px); }
        }
        @keyframes glitch-anim-2 {
            0% { clip-path: inset(10% 0 60% 0); transform: translate(2px, -1px); }
            20% { clip-path: inset(30% 0 20% 0); transform: translate(-2px, 1px); }
            40% { clip-path: inset(70% 0 10% 0); transform: translate(2px, -2px); }
            60% { clip-path: inset(20% 0 50% 0); transform: translate(-2px, 2px); }
            80% { clip-path: inset(50% 0 30% 0); transform: translate(1px, -1px); }
            100% { clip-path: inset(0% 0 80% 0); transform: translate(-1px, 1px); }
        }
        .cards-container {
            display: flex;
            gap: 40px;
            perspective: 1000px;
            z-index: 2;
            flex-wrap: wrap;
            justify-content: center;
        }
        .choice-card {
            width: 300px;
            height: 420px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 10, 20, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: #00ffff;
            font-family: monospace;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        .choice-card > * { position: relative; z-index: 2; } /* ƒê·∫£m b·∫£o n·ªôi dung n·∫±m tr√™n hi·ªáu ·ª©ng n·ªÅn */
        /* Hi·ªáu ·ª©ng Spotlight theo chu·ªôt */
        .choice-card::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(600px circle at var(--mouse-x) var(--mouse-y), rgba(0, 255, 255, 0.15), transparent 40%);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1;
        }
        .choice-card:hover::after { opacity: 1; }
        .choice-card.cpu-card::after {
            background: radial-gradient(600px circle at var(--mouse-x) var(--mouse-y), rgba(255, 0, 64, 0.15), transparent 40%);
        }
        /* Hi·ªáu ·ª©ng qu√©t Scanner cho th·∫ª */
        .choice-card::before {
            content: "";
            position: absolute;
            top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: 0.5s;
            top: -100%; left: 0; width: 100%; height: 40%;
            background: linear-gradient(to bottom, transparent, rgba(0, 255, 255, 0.5), transparent);
            transform: skewY(-10deg);
            pointer-events: none;
            transition: 0s;
        }
        .choice-card:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: #00ffff;
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2);
        }
        .choice-card:hover::before {
            animation: cardScan 1.5s linear infinite;
        }
        @keyframes cardScan {
            0% { top: -100%; }
            100% { top: 200%; }
        }
        @keyframes screenScan {
            0% { top: 0%; }
            100% { top: 100%; }
        }
        @keyframes spin {
            100% { transform: rotate(360deg); }
        }
        .choice-card.cpu-card {
            border-color: rgba(255, 0, 64, 0.3);
            color: #ff0040;
            background: rgba(20, 0, 5, 0.6);
        }
        .choice-card.cpu-card::before {
            background: linear-gradient(to bottom, transparent, rgba(255, 0, 64, 0.5), transparent);
        }
        .choice-card.cpu-card:hover {
            background: rgba(255, 0, 64, 0.1);
            border-color: #ff0040;
            box-shadow: 0 0 50px rgba(255, 0, 64, 0.2);
        }
        .choice-card.diag-card {
            border-color: rgba(255, 165, 0, 0.3);
            color: #ffa500;
            background: rgba(20, 10, 0, 0.6);
        }
        .choice-card.diag-card::before {
            background: linear-gradient(to bottom, transparent, rgba(255, 165, 0, 0.5), transparent);
        }
        .choice-card.diag-card:hover {
            background: rgba(255, 165, 0, 0.1);
            border-color: #ffa500;
            box-shadow: 0 0 50px rgba(255, 165, 0, 0.2);
        }
        .choice-card.diag-card::after {
            background: radial-gradient(600px circle at var(--mouse-x) var(--mouse-y), rgba(255, 165, 0, 0.15), transparent 40%);
        }
        #diag-scanner {
            position: fixed; top: 0; left: 0; width: 100%; height: 3px;
            background: #ffa500;
            box-shadow: 0 0 20px #ffa500, 0 0 10px #fff;
            z-index: 10000; pointer-events: none;
        }
        /* Credits Card & Star Wars Effect */
        .choice-card.credits-card {
            border-color: rgba(255, 215, 0, 0.3);
            color: #ffd700;
            background: rgba(20, 15, 0, 0.6);
        }
        .choice-card.credits-card::before {
            background: linear-gradient(to bottom, transparent, rgba(255, 215, 0, 0.5), transparent);
        }
        .choice-card.credits-card:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: #ffd700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.2);
        }
        .choice-card.credits-card::after {
            background: radial-gradient(600px circle at var(--mouse-x) var(--mouse-y), rgba(255, 215, 0, 0.15), transparent 40%);
        }
        
        /* AI Customization Card */
        .choice-card.ai-card {
            border-color: rgba(0, 191, 255, 0.3);
            color: #00bfff;
            background: rgba(0, 15, 25, 0.6);
        }
        .choice-card.ai-card::before {
            background: linear-gradient(to bottom, transparent, rgba(0, 191, 255, 0.5), transparent);
        }
        .choice-card.ai-card:hover {
            background: rgba(0, 191, 255, 0.1);
            border-color: #00bfff;
            box-shadow: 0 0 50px rgba(0, 191, 255, 0.2);
        }
        .choice-card.ai-card::after {
            background: radial-gradient(600px circle at var(--mouse-x) var(--mouse-y), rgba(0, 191, 255, 0.15), transparent 40%);
        }

        /* AI Settings Overlay */
        #ai-settings-overlay {
            background: rgba(0, 5, 10, 0.95); z-index: 11000; display: none;
            overflow-y: auto;
            backdrop-filter: blur(15px);
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        }
        #ai-settings-overlay .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #222;
            font-size: 16px;
            color: #ccc;
        }
        #ai-settings-overlay select, #ai-settings-overlay input[type="range"] {
            background: rgba(0,0,0,0.5);
            color: #00ffff;
            border: 1px solid #555;
            padding: 8px;
            font-family: monospace;
            cursor: pointer;
        }
        
        /* --- Developer Profile Card --- */
        .dev-profile-card {
            background: transparent;
            border: none;
            padding: 0;
            margin: 30px auto 50px;
            max-width: 500px;
            box-shadow: none;
            backdrop-filter: none;
            position: relative;
            overflow: visible;
        }
        .dev-profile-card::before {
            display: none;
        }
        .dev-frame-wrapper {
            position: relative;
            width: 220px;
            height: 220px;
            margin: 0 auto 40px;
        }
        .dev-frame-glow {
            position: absolute;
            top: -15px; left: -15px; right: -15px; bottom: -15px;
            border-radius: 50%;
            border: 1px dashed rgba(255, 215, 0, 0.4);
            border-top-color: #ffd700;
            border-bottom-color: #ffd700;
            animation: spin 10s linear infinite;
            z-index: 1;
        }
        .dev-frame-glow::after {
            content: '';
            position: absolute;
            top: -5px; left: -5px; right: -5px; bottom: -5px;
            border-radius: 50%;
            border: 1px solid rgba(255, 215, 0, 0.1);
            animation: spin 5s linear infinite reverse;
        }
        .dev-frame img { width: 100%; height: 100%; object-fit: cover; }
        .social-btn {
            text-decoration: none;
            padding: 10px 25px;
            font-family: monospace;
            font-weight: bold;
            border: 1px solid;
            transition: all 0.3s;
            font-size: 12px;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
            background: rgba(0,0,0,0.3);
            display: inline-block;
        }
        .social-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        
        #credits-overlay {
            background: rgba(0, 0, 0, 0.95); z-index: 11000; display: none;
            overflow-y: auto; /* Cho ph√©p cu·ªôn d·ªçc */
            backdrop-filter: blur(15px);
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        }
        /* Custom Scrollbar for Credits */
        #credits-overlay::-webkit-scrollbar { width: 8px; }
        #credits-overlay::-webkit-scrollbar-track { background: #000; }
        #credits-overlay::-webkit-scrollbar-thumb { background: #ffd700; border-radius: 4px; }

        .sw-container {
            display: flex; 
            flex-direction: column;
            align-items: center;
            min-height: 100%; 
            padding: 10vh 20px;
            box-sizing: border-box;
        }
        .sw-crawl {
            color: #ffd700; font-family: monospace; text-align: center;
            font-weight: bold; letter-spacing: 1px; line-height: 1.7;
            width: 90%; max-width: 900px;
            opacity: 0;
            animation: fadeInCredits 1s ease-out forwards;
            position: relative;
            top: auto;
            transform: none;
        }
        .sw-title { font-size: 80px; margin-bottom: 20px; text-shadow: 0 0 15px #ffd700; }
        .sw-subtitle { font-size: 40px; margin-bottom: 60px; color: #00ffff; }
        .sw-crawl h2 { font-size: 45px; margin: 10px 0 30px; color: #fff; }
        .sw-crawl h3 { font-size: 32px; margin: 10px 0 30px; color: #00ffff; }
        .sw-crawl p { font-size: 20px; color: #aaa; margin-bottom: 5px; }
        /* @keyframes crawl is no longer used */
        @keyframes fadeInCredits {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .choice-card h1 { font-size: 36px; margin: 0 0 10px 0; line-height: 1.2; }
        .choice-card p { font-size: 14px; opacity: 0.7; letter-spacing: 1px; }
        .card-icon {
            font-size: 64px;
            margin-bottom: 30px;
            transition: 0.3s;
            text-shadow: 0 0 10px currentColor;
        }
        .choice-card:hover .card-icon {
            transform: scale(1.2) rotate(5deg);
            text-shadow: 0 0 30px currentColor;
        }
        
        /* Typewriter Cursor Blink */
        @keyframes blinkCursor { 50% { border-color: transparent; } }
        
        /* Shooting Stars */
        .shooting-star {
            position: absolute;
            height: 2px;
            background: linear-gradient(to right, rgba(255,255,255,0), rgba(0,255,255,1) 50%, #fff);
            border-radius: 2px;
            filter: drop-shadow(0 0 5px #00ffff);
            pointer-events: none;
            opacity: 0;
            z-index: 1;
            animation: shoot 3s linear forwards;
        }
        @keyframes shoot {
            0% { transform: rotate(var(--angle)) translateX(0); width: 0; opacity: 1; }
            20% { width: 150px; opacity: 1; }
            100% { transform: rotate(var(--angle)) translateX(1500px); width: 0; opacity: 0; }
        }
        
        /* Fog Effect */
        #landing-screen::after {
            content: '';
            position: absolute;
            bottom: -10%; /* B·∫Øt ƒë·∫ßu b√™n d∆∞·ªõi ƒë·ªÉ c·∫°nh kh√¥ng b·ªã c·ª©ng */
            left: -50%;
            width: 200%;
            height: 50%;
            background: 
                radial-gradient(ellipse at 25% 100%, rgba(0, 25, 40, 0.6) 0%, transparent 50%),
                radial-gradient(ellipse at 75% 100%, rgba(0, 15, 25, 0.5) 0%, transparent 50%);
            filter: blur(40px);
            z-index: 1; /* N·∫±m tr√™n l∆∞·ªõi n·ªÅn v√† sao bƒÉng, d∆∞·ªõi c√°c th·∫ª */
            animation: driftFog 30s ease-in-out infinite alternate;
            pointer-events: none;
        }
        @keyframes driftFog {
            from { transform: translateX(-15%); }
            to { transform: translateX(15%); }
        }
        
        /* Ripple Effect */
        .ripple {
            position: absolute;
            border-radius: 50%;
            transform: scale(0);
            animation: ripple 0.6s linear;
            background-color: rgba(255, 255, 255, 0.4);
            pointer-events: none;
            z-index: 10;
        }
        @keyframes ripple { to { transform: scale(4); opacity: 0; } }
        
        /* Particle Styles */
        .landing-particle {
            position: absolute;
            background: #00ffff;
            border-radius: 50%;
            pointer-events: none;
            animation: floatUp linear infinite;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(0); opacity: 0; }
            20% { opacity: 0.6; }
            80% { opacity: 0.4; }
            100% { transform: translateY(-100vh) scale(1); opacity: 0; }
        }

        #cpu-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #0b1021 0%, #000 100%);
            z-index: 9999;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ffff;
            font-family: monospace;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            overflow: hidden;
        }
        /* N·ªÅn l∆∞·ªõi cho CPU Screen */
        #cpu-screen::before {
            content: "";
            position: absolute;
            top: -50%; left: -50%; width: 200%; height: 200%;
            background: 
                linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            transform: perspective(500px) rotateX(60deg);
            animation: cpuGridMove 20s linear infinite;
            pointer-events: none;
            z-index: -1;
        }
        @keyframes cpuGridMove {
            0% { transform: perspective(500px) rotateX(60deg) translateY(0); }
            100% { transform: perspective(500px) rotateX(60deg) translateY(50px); }
        }

        .cpu-dashboard {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            height: 100%;
            max-width: 1800px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
            padding: 20px;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }
        
        .cpu-grid-container {
            display: grid;
            grid-template-columns: 320px 1fr;
            grid-template-rows: 1fr;
            gap: 15px;
            flex: 1;
            min-height: 0; /* Cho ph√©p co nh·ªè chi·ªÅu cao */
        }

        .cpu-panel {
            background: rgba(5, 15, 25, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.6), inset 0 0 0 1px rgba(0, 255, 255, 0.05);
            padding: 20px;
            position: relative;
            backdrop-filter: blur(12px);
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        .cpu-panel:hover {
            border-color: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
        }
        .cpu-panel::after {
            content: "";
            position: absolute;
            top: -1px; left: -1px; width: 10px; height: 10px;
            border-top: 2px solid #00ffff;
            border-left: 2px solid #00ffff;
            border-top-left-radius: 6px;
        }
        .cpu-panel::before {
            content: "";
            position: absolute;
            bottom: -1px; right: -1px; width: 10px; height: 10px;
            border-bottom: 2px solid #00ffff;
            border-right: 2px solid #00ffff;
            border-bottom-right-radius: 6px;
        }

        .monitor-wrapper {
            flex: 1;
            position: relative;
            width: 100%;
            min-height: 0; /* Quan tr·ªçng ƒë·ªÉ canvas co gi√£n */
            border: none;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            background: #000;
            overflow: hidden;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.9);
        }
        .monitor-scanline {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }
        
        .cyber-progress-container {
            width: 100%;
            height: 24px;
            background: #111;
            border: 1px solid #00ffff;
            padding: 2px;
            margin-top: 10px;
            position: relative;
        }
        .cyber-progress-bar {
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                #00ffff,
                #00ffff 10px,
                #0088ff 10px,
                #0088ff 20px
            );
            width: 0%;
            transition: width 0.2s;
            box-shadow: 0 0 15px #00ffff;
            position: relative;
        }
        .cyber-progress-bar::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
            animation: shimmer 1s infinite;
        }
        @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }

        /* Layout specific adjustments */
        .cpu-dashboard .panel-header { 
            flex: 0 0 auto;
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            background: linear-gradient(90deg, rgba(0, 40, 60, 0.9), rgba(0, 10, 20, 0.9));
            border-bottom: 1px solid #00ffff; 
            padding: 15px 20px;
            margin-bottom: 0;
        }
        .panel-sidebar { 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            overflow-y: auto;
            padding-right: 5px;
        }
        .panel-main { 
            display: flex; 
            flex-direction: column; 
            padding: 0 !important; /* Reset padding */
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
        }
        .cpu-stats-area {
            padding: 15px;
            flex: 0 0 auto;
            background: rgba(0, 20, 40, 0.3);
        }
        
        /* Scrollbar styling for sidebar */
        .panel-sidebar::-webkit-scrollbar { width: 4px; }
        .panel-sidebar::-webkit-scrollbar-thumb { background: #005555; border-radius: 2px; }

        @media (max-width: 900px) {
            .cpu-grid-container { 
                grid-template-columns: 1fr; 
                grid-template-rows: auto 1fr; 
                overflow-y: auto; 
            }
            .panel-sidebar { 
                flex-direction: row; 
                flex-wrap: wrap; 
                flex: 0 0 auto;
            }
            .panel-sidebar > .cpu-panel {
                flex: 1;
                min-width: 250px;
            }
            .monitor-wrapper { min-height: 250px; }
        }
        
        /* Class ƒë·ªÉ ·∫©n UI game khi ·ªü menu */
        .game-ui { display: none !important; }

        /* --- Leaderboard --- */
        .leaderboard {
            margin-top: 20px;
            width: 90%;
            max-width: 600px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #555;
            color: #fff;
            font-weight: bold;
            text-transform: uppercase;
            background: rgba(0, 0, 0, 0.3);
        }
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid #222;
            color: #aaa;
            font-family: monospace;
            transition: background 0.2s;
        }
        .leaderboard-item:hover { background: rgba(255, 255, 255, 0.05); }
        .leaderboard-item.user {
            color: #00ff00;
            font-weight: bold;
            background: rgba(0, 255, 0, 0.15);
            border: 1px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            transform: scale(1.02);
            margin: 5px 0;
        }
        .leaderboard-rank { width: 40px; text-align: left; }
        .leaderboard-name { flex-grow: 1; text-align: left; }
        .leaderboard-score { width: 100px; text-align: right; }

        /* --- T√çNH NƒÇNG M·ªöI: Draggable Control Panel --- */
        #control-panel {
            position: fixed;
            top: 100px;
            left: 20px;
            width: 300px;
            background: rgba(0, 15, 25, 0.8);
            border: 1px solid #00ffff;
            color: #00ff00;
            font-family: monospace;
            z-index: 1100;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            color: #00ffff;
        }
        #control-panel .panel-header {
            background: rgba(0, 255, 255, 0.1);
            padding: 8px 12px;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: bold;
            user-select: none;
        }
        .panel-toggle-btn {
            cursor: pointer;
            border: 1px solid #00ffff;
            background: none;
            color: #00ffff;
            width: 20px;
            height: 20px;
            line-height: 18px;
            text-align: center;
        }
        .panel-body {
            padding: 15px;
            max-height: 450px; /* TƒÉng chi·ªÅu cao t·ªëi ƒëa */
            overflow-y: auto;
            transition: all 0.3s ease-in-out;
        }
        #control-panel.collapsed .panel-body {
            max-height: 0;
            padding: 0 15px;
            overflow: hidden;
        }
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 12px;
        }
        .control-row label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        input[type="checkbox"] {
            accent-color: #00ffff;
            margin-right: 10px;
        }
        #system-log-container {
            margin-top: 15px;
            border-top: 1px dashed #00ffff55;
            padding-top: 10px;
            height: 120px;
            font-size: 11px;
            overflow-y: auto;
            background: rgba(0,0,0,0.2);
            color: #00ff00;
        }
        .log-entry { margin-top: 2px; opacity: 0.9; }
        /* Scrollbar styling */
        .panel-body::-webkit-scrollbar, #system-log-container::-webkit-scrollbar {
            width: 4px;
        }
        .panel-body::-webkit-scrollbar-track, #system-log-container::-webkit-scrollbar-track {
            background: #001122;
        }
        .panel-body::-webkit-scrollbar-thumb, #system-log-container::-webkit-scrollbar-thumb {
            background: #00ffff;
        }

        /* --- T√çNH NƒÇNG M·ªöI: AI Assistant Widget --- */
        #ai-widget {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            pointer-events: none; /* ƒê·ªÉ click xuy√™n qua v√πng tr·ªëng */
        }
        .ai-avatar {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            border: 2px solid #00ffff;
            position: relative;
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.3s, box-shadow 0.3s;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        .ai-avatar:hover { transform: scale(1.1); box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); }
        .ai-avatar:active { transform: scale(0.95); }
        .ai-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            opacity: 0.9;
        }
        .ai-ring {
            position: absolute;
            top: -6px; left: -6px; right: -6px; bottom: -6px;
            border: 1px dashed #00ffff;
            border-radius: 50%;
            animation: spin 10s linear infinite;
            pointer-events: none;
        }
        .ai-bubble {
            background: rgba(0, 15, 25, 0.9);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 12px 18px;
            border-radius: 15px 15px 0 15px;
            margin-bottom: 15px;
            font-family: monospace;
            font-size: 12px;
            max-width: 220px;
            opacity: 0;
            transform: translateY(20px) scale(0.8);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        .ai-halo {
            position: absolute;
            width: 50px;
            height: 15px;
            border: 3px solid #00ffff;
            border-radius: 50%;
            top: -8px;
            left: 40%;
            transform: translateX(-50%) rotate(-15deg);
            z-index: 1;
            pointer-events: none;
            transition: all 0.3s;
            opacity: 1;
        }
        .ai-bubble.show { opacity: 1; transform: translateY(0) scale(1); }
    </style>
</head>
<body>
    <div id="loading">ƒêang t·∫£i t√†i nguy√™n 3D...</div>
    <div id="transition-overlay"></div>
    <div id="cinematic-bar-top" class="cinematic-bar"></div>
    <div id="cinematic-bar-bottom" class="cinematic-bar"></div>

    <!-- LANDING SCREEN -->
    <div id="landing-screen">
        <div class="landing-title" data-text="QUANTUM CORE">QUANTUM CORE</div>
        <div class="cards-container" id="cards-container">
            <div class="choice-card" onclick="startBenchmarkMode()">
                <div class="card-icon">‚ö°</div>
                <h1>GPU<br>BENCHMARK</h1>
                <p>VISUAL STRESS TEST</p>
                <div style="margin-top: 20px; font-size: 10px; opacity: 0.5;">WEBGL 2.0 ‚Ä¢ RAYTRACING</div>
            </div>
            <div class="choice-card diag-card" onclick="runDiagnostics()">
                <div class="card-icon">üì°</div>
                <h1>SYSTEM<br>DIAGNOSTICS</h1>
                <p>RUN ON-SCREEN CHECK</p>
                <div style="margin-top: 20px; font-size: 10px; opacity: 0.5;">UI ‚Ä¢ ANIMATION ‚Ä¢ DOM</div>
            </div>
            <div class="choice-card credits-card" onclick="showCredits()">
                <div class="card-icon">üìú</div>
                <h1>CREDITS</h1>
                <p>BEHIND THE SCENES</p>
                <div style="margin-top: 20px; font-size: 10px; opacity: 0.5;">CREATOR ‚Ä¢ TECH STACK</div>
            </div>
            <div class="choice-card cpu-card" onclick="startCpuMode()">
                <div class="card-icon">üß†</div>
                <h1>CPU<br>COMPUTE</h1>
                <p>MULTI-THREAD TEST</p>
                <div style="margin-top: 20px; font-size: 10px; opacity: 0.5;">WORKER THREADS ‚Ä¢ PHYSICS</div>
            </div>
            <div class="choice-card ai-card" onclick="showAiSettings()">
                <div class="card-icon">ü§ñ</div>
                <h1>AI<br>ASSISTANT</h1>
                <p>CUSTOMIZE ARONA</p>
                <div style="margin-top: 20px; font-size: 10px; opacity: 0.5;">PERSONALITY CORE</div>
            </div>
        </div>
        <div id="typewriter-text" style="position: absolute; bottom: 20px; color: #555; font-size: 12px; font-family: monospace; border-right: 2px solid #555; padding-right: 5px; white-space: nowrap;"></div>
    </div>

    <!-- CREDITS OVERLAY -->
    <div id="credits-overlay">
        <div class="sw-container">
            <div class="sw-crawl" id="sw-crawl-content">
                <div class="sw-title" style="margin-top: 0;">QUANTUM CORE</div>
                <div class="sw-subtitle">THE NEXT GEN WEBGL BENCHMARK</div>
                
                <div style="margin: 60px 0; border-top: 1px solid rgba(255, 215, 0, 0.3); border-bottom: 1px solid rgba(255, 215, 0, 0.3); padding: 40px 0;">
                    <p style="color: #fff; font-size: 24px; margin-bottom: 20px;">PROJECT VISION</p>
                    <p style="max-width: 700px; margin: 0 auto; color: #ccc; font-weight: normal; font-size: 20px;">
                        Quantum Core was designed to push the boundaries of what is possible in a web browser. 
                        Combining advanced Raytracing techniques, Volumetric Physics, and Real-time Audio Analysis, 
                        it serves as both a visual spectacle and a rigorous hardware stress test.
                    </p>
                </div>

                <div class="dev-profile-card">
                    <div class="dev-frame-wrapper">
                        <div class="dev-frame" style="width: 100%; height: 100%; border: 2px solid #ffd700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.2); margin: 0; border-radius: 50%; overflow: hidden;">
                            <img src="plana.jpg" alt="Developer Avatar">
                        </div>
                        <div class="dev-frame-glow"></div>
                    </div>
                    <h2 style="color: #ffd700; text-shadow: 0 0 15px rgba(255, 215, 0, 0.6); margin: 20px 0 10px; font-size: 36px; letter-spacing: 2px;">BAO-arona</h2>
                    <p style="font-size: 14px; color: #888; margin-bottom: 40px; letter-spacing: 4px; text-transform: uppercase;">Architect & Engineer</p>

                    <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                        <a href="https://github.com/phamb6650-collab" target="_blank" class="social-btn" style="border-color: #fff; color: #fff;">GITHUB</a>
                        <a href="https://www.youtube.com/channel/UCqBYYInBcfCyXwN5c1V0vZw" target="_blank" class="social-btn" style="border-color: #ff0000; color: #ff0000;">YOUTUBE</a>
                        <a href="https://www.facebook.com/pham.bao.213966" target="_blank" class="social-btn" style="border-color: #1877f2; color: #1877f2;">FACEBOOK</a>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 50px; text-align: left; max-width: 700px; margin: 0 auto;">
                    <div>
                        <h3 style="color: #00ffff; border-bottom: 1px solid #00ffff; padding-bottom: 10px; font-size: 28px;">CORE TECH</h3>
                        <ul style="list-style: none; padding: 0; color: #aaa; font-weight: normal; font-size: 18px;">
                            <li style="margin-bottom: 15px;">‚Ä¢ Three.js Engine</li>
                            <li style="margin-bottom: 15px;">‚Ä¢ WebGL 2.0</li>
                            <li style="margin-bottom: 15px;">‚Ä¢ GLSL Shaders</li>
                            <li style="margin-bottom: 15px;">‚Ä¢ Web Workers</li>
                        </ul>
                    </div>
                    <div>
                        <h3 style="color: #ff00ff; border-bottom: 1px solid #ff00ff; padding-bottom: 10px; font-size: 28px;">FEATURES</h3>
                        <ul style="list-style: none; padding: 0; color: #aaa; font-weight: normal; font-size: 18px;">
                            <li style="margin-bottom: 15px;">‚Ä¢ Real-time Raytracing</li>
                            <li style="margin-bottom: 15px;">‚Ä¢ Volumetric Fog</li>
                            <li style="margin-bottom: 15px;">‚Ä¢ Audio Reactivity</li>
                            <li style="margin-bottom: 15px;">‚Ä¢ Physics Simulation</li>
                        </ul>
                    </div>
                </div>

                <div style="margin-top: 80px;">
                    <p style="font-size: 16px; color: #666;">SPECIAL THANKS TO</p>
                    <h3 style="color: #fff; font-size: 32px;">OPEN SOURCE COMMUNITY</h3>
                    <p style="margin-top: 30px; font-style: italic; color: #ffd700; font-size: 20px;">I LOVE YOU</p>
                </div>
                
                <div style="height: 100px;"></div>
            </div>
        </div>
        <button class="quality-btn" style="position: fixed; top: 30px; right: 30px; border-color: #ffd700; color: #ffd700; z-index: 11001;" onclick="hideCredits()">CLOSE CREDITS</button>
    </div>

    <!-- AI SETTINGS OVERLAY -->
    <div id="ai-settings-overlay">
        <div class="sw-container">
             <div class="sw-crawl">
                <div class="dev-profile-card">
                    <div class="dev-frame-wrapper">
                        <div class="dev-frame" style="width: 100%; height: 100%; border: 2px solid #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.2); margin: 0; border-radius: 50%; overflow: hidden;">
                            <img src="arona.jpg" alt="Arona Avatar">
                        </div>
                        <div class="dev-frame-glow" style="border-color: rgba(0, 255, 255, 0.4); border-top-color: #00ffff; border-bottom-color: #00ffff;"></div>
                    </div>
                    <h2 style="color: #00ffff; text-shadow: 0 0 15px rgba(0, 255, 255, 0.6); margin: 20px 0 10px; font-size: 36px; letter-spacing: 2px;">ARONA</h2>
                    <p style="font-size: 14px; color: #888; margin-bottom: 40px; letter-spacing: 4px; text-transform: uppercase;">SYSTEM AI</p>
                </div>

                <div style="max-width: 500px; margin: 40px auto; text-align: left;">
                    <h3 style="color: #fff; border-bottom: 1px solid #555; padding-bottom: 10px;">SETTINGS</h3>
                    <div class="control-row">
                        <label for="toggle-ai-widget">Enable AI Assistant</label>
                        <input type="checkbox" id="toggle-ai-widget" checked>
                    </div>
                    <div class="control-row">
                        <label for="select-ai-avatar">Avatar</label>
                        <select id="select-ai-avatar">
                            <option value="arona">Arona</option>
                            <option value="plana">Plana</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label for="toggle-ai-halo">Summon Halo on Click</label>
                        <input type="checkbox" id="toggle-ai-halo" checked>
                    </div>
                    <div class="control-row">
                        <label for="slider-ai-volume">Voice Volume</label>
                        <input type="range" id="slider-ai-volume" min="0" max="1" step="0.1" value="0.8">
                    </div>
                    <div class="control-row">
                        <label for="toggle-character-halo">Show Character Halo</label>
                        <input type="checkbox" id="toggle-character-halo" checked>
                    </div>
                    <div class="control-row">
                        <label for="color-ai-halo">Halo Color</label>
                        <input type="color" id="color-ai-halo" value="#00ffff">
                    </div>
                </div>
             </div>
        </div>
        <button class="quality-btn" style="position: fixed; top: 30px; right: 30px; border-color: #00ffff; color: #00ffff; z-index: 11001;" onclick="hideAiSettings()">CLOSE</button>
    </div>

    <!-- AI ASSISTANT WIDGET -->
    <div id="ai-widget">
        <div class="ai-bubble" id="ai-bubble">System Online. Welcome back, Sensei.</div>
        <div class="ai-avatar" onclick="window.handleAiClick()">
            <div class="ai-halo"></div>
            <div class="ai-ring"></div>
            <img src="arona.jpg" alt="AI">
        </div>
    </div>

    <!-- CPU TEST SCREEN -->
    <div id="cpu-screen">
        <div class="cpu-dashboard">
            <!-- Header -->
            <div class="cpu-panel panel-header">
                <h2 style="margin: 0; font-size: 20px; font-weight: bold; text-shadow: 0 0 10px #00ffff;">CPU RAYTRACING CORE</h2>
                <div style="display: flex; align-items: center; gap: 20px;">
                    <div id="cpu-system-info" style="font-size: 12px; color: #aaa; text-align: right;">DETECTING HARDWARE...</div>
                    <button class="quality-btn" style="border-color: #ff5555; color: #ff5555; padding: 5px 15px; font-size: 12px;" onclick="location.reload()">EXIT</button>
                </div>
            </div>

            <div class="cpu-grid-container">
            <!-- Sidebar: Controls & Scores -->
            <div class="panel-sidebar">
                <div class="cpu-panel">
                    <h3 style="margin-top: 0; border-bottom: 1px solid #555; padding-bottom: 5px; color: #00ffff;">CONTROLS</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <label style="font-size: 12px; color: #888;">RESOLUTION</label>
                        <select id="cpu-res-select" style="background: rgba(0,0,0,0.5); color: #00ffff; border: 1px solid #00ffff; padding: 8px; font-family: monospace; cursor: pointer; width: 100%;">
                            <option value="640x360">SD (640x360)</option>
                            <option value="1280x720">HD (1280x720)</option>
                            <option value="1920x1080">Full HD (1920x1080)</option>
                            <option value="3840x2160">4K (3840x2160)</option>
                        </select>
                        <label style="font-size: 12px; color: #888; margin-top: 10px;">QUALITY</label>
                        <select id="cpu-quality-select" style="background: rgba(0,0,0,0.5); color: #00ffff; border: 1px solid #00ffff; padding: 8px; font-family: monospace; cursor: pointer; width: 100%;">
                            <option value="draft">Draft (Fast)</option>
                            <option value="standard" selected>Standard (Balanced)</option>
                            <option value="extreme">Extreme (Very Slow)</option>
                        </select>
                        <button id="cpu-start-btn" class="quality-btn" style="width: 100%; margin-top: 10px; border-color: #00ff00; color: #00ff00;">INITIALIZE TEST</button>
                        <div id="cpu-pause-controls" style="display: none; flex-direction: row; gap: 10px; margin-top: 10px;">
                            <button id="cpu-pause-btn" class="quality-btn" style="flex: 1; border-color: #ffaa00; color: #ffaa00;">PAUSE</button>
                            <button id="cpu-resume-btn" class="quality-btn" style="flex: 1; border-color: #00ff00; color: #00ff00; display: none;">RESUME</button>
                        </div>
                    </div>
                </div>

                <div class="cpu-panel" style="flex-grow: 1;">
                    <h3 style="margin-top: 0; border-bottom: 1px solid #555; padding-bottom: 5px; color: #ff0040;">LIVE METRICS</h3>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                        <div id="score-single" style="text-align: center;">
                            <div style="font-size: 10px; color: #888;">SINGLE-CORE</div>
                            <div class="val" style="font-size: 24px; font-weight: bold; color: #fff; text-shadow: 0 0 10px #fff;">---</div>
                        </div>
                        <div id="score-multi" style="text-align: center;">
                            <div style="font-size: 10px; color: #888;">MULTI-CORE</div>
                            <div class="val" style="font-size: 24px; font-weight: bold; color: #fff; text-shadow: 0 0 10px #fff;">---</div>
                        </div>
                    </div>
                    <div id="cpu-results" style="font-size: 12px; line-height: 1.4; color: #ccc; height: 200px; overflow-y: auto;">WAITING FOR INPUT...</div>
                </div>
            </div>

            <!-- Main: Render Canvas -->
            <div class="cpu-panel panel-main">
                <div class="monitor-wrapper">
                    <div class="monitor-scanline"></div>
                    <canvas id="cpu-render-canvas" width="640" height="360" style="width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated;"></canvas>
                </div>
                <div class="cpu-stats-area">
                <div style="margin-top: 0px;">
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #00ffff; margin-bottom: 5px;">
                        <span id="cpu-status">SYSTEM IDLE</span>
                        <span>PROGRESS</span>
                    </div>
                    <div class="cyber-progress-container">
                        <div class="cyber-progress-bar" id="cpu-progress"></div>
                    </div>
                    <!-- Temp Chart -->
                    <div id="temp-chart-wrapper" style="margin-top: 15px; display: none;">
                        <div style="display: flex; justify-content: space-between; font-size: 10px; color: #ff5555; margin-bottom: 5px;">
                            <span>CPU THERMAL MONITOR (SIMULATED)</span>
                            <span id="current-temp-display">35.0¬∞C</span>
                        </div>
                        <canvas id="cpu-temp-chart" width="600" height="100" style="width: 100%; height: 80px; background: rgba(20, 0, 0, 0.3); border: 1px solid #552222;"></canvas>
                    </div>
                </div>
                <canvas id="cpu-chart-canvas" width="600" height="200" style="width: 100%; height: 150px; margin-top: 20px; background: rgba(0,0,0,0.2); border: 1px solid #333; display: none;"></canvas>
                </div>
            </div>
            </div>
        </div>
    </div>

    <div id="benchmark-modal">
        <h2 style="margin-top: 0; color: #fff;">SYSTEM ANALYSIS COMPLETE</h2>
        <div style="font-size: 14px; color: #888; margin-bottom: 10px;">PERFORMANCE SCORE</div>
        <div id="benchmark-score" style="font-size: 60px; font-weight: bold; margin: 20px 0; text-shadow: 0 0 20px #00ffff; color: #fff;">0</div>
        <div id="benchmark-fps" style="font-size: 20px; margin-bottom: 20px;">AVG FPS: 0</div>
        <button onclick="document.getElementById('benchmark-modal').style.display='none'" class="quality-btn" style="width: 100%;">CLOSE</button>
    </div>
    <div class="game-ui" style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #888; font-size: 12px; pointer-events: none; z-index: 1000; text-shadow: 0 0 5px #000;">[Left Click] Attract | [Right Click] Repel</div>
    
    <div class="quality-controls game-ui">
        <button class="quality-btn" onclick="window.setQuality(0)">Super Low</button>
        <button class="quality-btn active" onclick="window.setQuality(1)">Low</button>
        <button class="quality-btn" onclick="window.setQuality(2)">Medium</button>
        <button class="quality-btn" onclick="window.setQuality(3)">High</button>
        <button class="quality-btn" onclick="window.setQuality(4)">Ultra</button>
        <button class="quality-btn" onclick="window.setQuality(5)">Extreme</button>
    </div>

    <button id="warp-btn" class="game-ui">ENGAGE WARP</button>
    <button id="audio-btn" class="game-ui">ENABLE MIC</button>
    <button id="director-btn" class="game-ui">AUTO DIRECTOR</button>
    <button id="benchmark-btn" class="game-ui">RUN BENCHMARK</button>

    <!-- T√çNH NƒÇNG M·ªöI: Draggable Control Panel -->
    <div id="control-panel" class="game-ui">
        <div class="panel-header" id="panel-header">
            <span>SYSTEM CONTROL</span>
            <button class="panel-toggle-btn" id="panel-toggle-btn">-</button>
        </div>
        <div class="panel-body">
            <div class="control-row">
                <span>TIME SCALE</span>
                <input type="range" id="time-slider" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-row">
                <span>THEME</span>
                <select id="theme-select" style="background: #000; border: 1px solid #555; color: #00ffff; font-family: monospace;">
                    <option value="cyberpunk">CYBERPUNK</option>
                    <option value="matrix">MATRIX</option>
                    <option value="inferno">INFERNO</option>
                    <option value="oceanic">OCEANIC</option>
                    <option value="vaporwave">VAPORWAVE</option>
                </select>
            </div>
            
            <h4 style="margin: 20px 0 10px; border-bottom: 1px solid #555; padding-bottom: 5px;">EFFECTS</h4>
            <div class="control-row">
                <label><input type="checkbox" id="toggle-reflections" checked>Real-time Reflections</label>
            </div>
            <div class="control-row">
                <label><input type="checkbox" id="toggle-fog" checked>Volumetric Fog</label>
            </div>
            <div class="control-row">
                <label><input type="checkbox" id="toggle-debris" checked>Debris Field</label>
            </div>
            <div class="control-row">
                <label><input type="checkbox" id="toggle-lines" checked>Neural Lines</label>
            </div>

            <h4 style="margin: 20px 0 10px; border-bottom: 1px solid #555; padding-bottom: 5px;">TRIGGERS</h4>
            <button id="glitch-btn" class="quality-btn" style="width: 100%; text-align: center; margin-bottom: 5px;">TRIGGER GLITCH</button>
            <button id="blackhole-btn" class="quality-btn" style="width: 100%; text-align: center; margin-bottom: 5px; border-color: #ff00ff; color: #ff00ff;">ACTIVATE BLACK HOLE</button>
            <button id="supernova-btn" class="quality-btn" style="width: 100%; text-align: center; margin-bottom: 5px; border-color: #ffaa00; color: #ffaa00;">TRIGGER SUPERNOVA</button>
            <button id="scan-btn" class="quality-btn" style="width: 100%; text-align: center; margin-bottom: 5px; border-color: #00ffff; color: #00ffff;">SYSTEM SCAN</button>
            <button id="rain-btn" class="quality-btn" style="width: 100%; text-align: center; margin-bottom: 5px; border-color: #00ff00; color: #00ff00;">DIGITAL RAIN</button>
            <button id="wireframe-btn" class="quality-btn" style="width: 100%; text-align: center; margin-bottom: 5px; border-color: #ffffff; color: #ffffff;">WIREFRAME MODE</button>
            <button id="screenshot-btn" class="quality-btn" style="width: 100%; text-align: center;">SCREENSHOT</button>

            <h4 style="margin: 20px 0 10px; border-bottom: 1px solid #555; padding-bottom: 5px;">SESSION</h4>
            <button onclick="location.reload()" class="quality-btn" style="width: 100%; text-align: center; border-color: #ff5555; color: #ff5555;">EXIT TO HOME</button>

            <div id="system-log-container">
                <!-- Log entries will be injected here -->
            </div>
        </div>
    </div>

    <!-- Import map ƒë·ªÉ load Three.js t·ª´ CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import Stats from 'three/addons/libs/stats.module.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
        import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
        import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
        import { GodRaysFakeSunShader, GodRaysDepthMaskShader, GodRaysGenerateShader, GodRaysCombineShader } from 'three/addons/shaders/GodRaysShader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // 1. C·∫•u h√¨nh c∆° b·∫£n (Scene, Camera, Renderer)
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        // --- T√çNH NƒÇNG M·ªöI: Matrix Rain Background ---
        const matrixCanvas = document.createElement('canvas');
        matrixCanvas.width = window.innerWidth;
        matrixCanvas.height = window.innerHeight;
        const matrixContext = matrixCanvas.getContext('2d');
        
        // Kh·ªüi t·∫°o n·ªÅn ƒëen
        matrixContext.fillStyle = '#000';
        matrixContext.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);

        const matrixTexture = new THREE.CanvasTexture(matrixCanvas);
        scene.background = matrixTexture;

        const matrixFontSize = 14;
        let matrixColumns = Math.floor(window.innerWidth / matrixFontSize);
        const matrixDrops = [];
        for(let i = 0; i < matrixColumns; i++) {
            matrixDrops[i] = 1;
        }
        const matrixChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()ÔΩ¶ÔΩßÔΩ®ÔΩ©ÔΩ™ÔΩ´ÔΩ¨ÔΩ≠ÔΩÆÔΩØÔΩ±ÔΩ≤ÔΩ≥ÔΩ¥ÔΩµÔΩ∂ÔΩ∑ÔΩ∏ÔΩπÔΩ∫ÔΩªÔΩºÔΩΩÔΩæÔΩøÔæÄÔæÅÔæÇÔæÉÔæÑÔæÖÔæÜÔæáÔæàÔæâÔæäÔæãÔæåÔæçÔæéÔæèÔæêÔæëÔæíÔæìÔæîÔæïÔæñÔæóÔæòÔæôÔæöÔæõÔæúÔæù";
        let matrixColor = '#00ff00'; // Bi·∫øn l∆∞u m√†u Matrix

        function drawMatrixRain() {
            // Hi·ªáu ·ª©ng m·ªù d·∫ßn (Trails)
            matrixContext.fillStyle = 'rgba(0, 0, 0, 0.05)'; 
            matrixContext.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
            
            matrixContext.fillStyle = matrixColor; // S·ª≠ d·ª•ng bi·∫øn m√†u ƒë·ªông
            matrixContext.font = matrixFontSize + 'px monospace';
            
            for(let i = 0; i < matrixDrops.length; i++) {
                const text = matrixChars.charAt(Math.floor(Math.random() * matrixChars.length));
                matrixContext.fillText(text, i * matrixFontSize, matrixDrops[i] * matrixFontSize);
                
                // Reset ng·∫´u nhi√™n khi ch·∫°m ƒë√°y
                if(matrixDrops[i] * matrixFontSize > matrixCanvas.height && Math.random() > 0.975)
                    matrixDrops[i] = 0;
                
                matrixDrops[i]++;
            }
            matrixTexture.needsUpdate = true;
        }

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 0, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Gi·ªõi h·∫°n pixel ratio t·ªëi ƒëa l√† 2 ƒë·ªÉ t·ªëi ∆∞u hi·ªáu nƒÉng mobile
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.5; // Gi·∫£m ƒë·ªô ph∆°i s√°ng t·ªïng th·ªÉ
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 2. Th√™m FPS Counter (Stats)
        const stats = new Stats();
        stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
        
        // T√πy ch·ªânh style cho Stats d·ª±a tr√™n thi·∫øt b·ªã
        const isMobile = window.innerWidth < 768;
        const statsScale = isMobile ? '1.0' : '1.5'; // Mobile th√¨ nh·ªè l·∫°i
        
        // Chuy·ªÉn xu·ªëng g√≥c d∆∞·ªõi b√™n tr√°i
        stats.dom.style.cssText = `position:fixed;bottom:0px;left:0px;cursor:pointer;opacity:0.9;z-index:10000;transform:scale(${statsScale});transform-origin:bottom left;`;
        
        // ·∫®n Stats ban ƒë·∫ßu
        stats.dom.style.display = 'none';
        document.body.appendChild(stats.dom);

        // --- T√çNH NƒÇNG M·ªöI: Memory Stats (Bi·ªÉu ƒë·ªì b·ªô nh·ªõ) ---
        const statsMem = new Stats();
        statsMem.showPanel(2); // 0: fps, 1: ms, 2: mb
        const statsWidth = 80 * parseFloat(statsScale);
        statsMem.dom.style.cssText = `position:fixed;bottom:0px;left:${statsWidth}px;cursor:pointer;opacity:0.9;z-index:10000;transform:scale(${statsScale});transform-origin:bottom left;`;
        
        // ·∫®n Stats ban ƒë·∫ßu
        statsMem.dom.style.display = 'none';
        document.body.appendChild(statsMem.dom);

        // --- T√çNH NƒÇNG M·ªöI: Hi·ªÉn th·ªã th√¥ng tin GPU ---
        const gl = renderer.getContext();
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        const rendererInfo = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown GPU';
        
        const gpuDiv = document.createElement('div');
        gpuDiv.id = 'gpu-info';
        // T√≠nh to√°n v·ªã tr√≠ b√™n c·∫°nh Stats (FPS + Mem)
        const totalStatsWidth = statsWidth * 2;
        gpuDiv.style.cssText = `position:fixed;bottom:0px;left:${totalStatsWidth}px;color:#00ffff;font-family:monospace;font-size:11px;background:rgba(0,0,0,0.7);padding:4px 8px;border:1px solid #00ffff;pointer-events:none;z-index:10000;white-space:nowrap;`;
        gpuDiv.innerHTML = `GPU: ${rendererInfo}<br>Res: ${window.innerWidth}x${window.innerHeight}`;
        
        // ·∫®n GPU Info ban ƒë·∫ßu
        gpuDiv.style.display = 'none';
        document.body.appendChild(gpuDiv);

        // 3. ƒêi·ªÅu khi·ªÉn Camera (OrbitControls)
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 80; // Gi·ªõi h·∫°n zoom xa ch·∫∑t h∆°n ƒë·ªÉ t·∫≠p trung v√†o c·∫£nh ch√≠nh
        controls.minDistance = 20;  // Gi·ªõi h·∫°n zoom g·∫ßn ƒë·ªÉ kh√¥ng xuy√™n qua v·∫≠t th·ªÉ
        controls.maxPolarAngle = Math.PI / 1.5; // Gi·ªõi h·∫°n g√≥c nh√¨n t·ª´ d∆∞·ªõi l√™n
        controls.minPolarAngle = Math.PI / 6;   // Gi·ªõi h·∫°n g√≥c nh√¨n t·ª´ tr√™n xu·ªëng

        // --- N√ÇNG C·∫§P: Post-processing (Hi·ªáu ·ª©ng Bloom ph√°t s√°ng) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.6; // TƒÉng ng∆∞·ª°ng ƒë·ªÉ ch·ªâ v√πng r·∫•t s√°ng m·ªõi ph√°t quang
        bloomPass.strength = 0.2;  // Gi·∫£m ƒë·ªô m·∫°nh ƒë·ªÉ b·ªõt ch√≥i
        bloomPass.radius = 0.5;    // B√°n k√≠nh lan t·ªèa
        
        const afterimagePass = new AfterimagePass();
        afterimagePass.uniforms['damp'].value = 0.85; // T·∫°o hi·ªáu ·ª©ng b√≥ng m·ªù (trails)
        
        // --- N√ÇNG C·∫§P: Cinematic Effects (Hi·ªáu ·ª©ng ƒëi·ªán ·∫£nh) ---
        const effectFilm = new FilmPass(0.35, 0.025, 648, false); // Nhi·ªÖu h·∫°t v√† scanlines
        
        const effectShift = new ShaderPass(RGBShiftShader); // T√°ch m√†u RGB
        effectShift.uniforms['amount'].value = 0.0015;

        // --- N√ÇNG C·∫§P: Depth of Field (Bokeh) ---
        const bokehPass = new BokehPass(scene, camera, {
            focus: 50.0,
            aperture: 0.0001,
            maxblur: 0.01,
        });
        bokehPass.enabled = false; // M·∫∑c ƒë·ªãnh t·∫Øt (Low setting)

        // --- N√ÇNG C·∫§P: SSAO (Screen Space Ambient Occlusion) - Hi·ªáu ·ª©ng b√≥ng ƒë·ªï khe k·∫Ω c·ª±c n·∫∑ng ---
        const ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
        ssaoPass.kernelRadius = 16; // B√°n k√≠nh b√≥ng ƒë·ªï
        ssaoPass.minDistance = 0.005;
        ssaoPass.maxDistance = 0.1;
        ssaoPass.enabled = false; // M·∫∑c ƒë·ªãnh t·∫Øt (Low setting)

        // --- N√ÇNG C·∫§P: God Rays Pass (Tia s√°ng th·∫ßn th√°nh) ---
        // Shader t√πy ch·ªânh ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng Radial Blur (God Rays) t·ª´ t√¢m
        const godRaysShader = {
            uniforms: {
                tDiffuse: { value: null },
                fX: { value: 0.5 }, // T·ªça ƒë·ªô X c·ªßa ngu·ªìn s√°ng tr√™n m√†n h√¨nh
                fY: { value: 0.5 }, // T·ªça ƒë·ªô Y c·ªßa ngu·ªìn s√°ng tr√™n m√†n h√¨nh
                fExposure: { value: 0.3 },
                fDecay: { value: 0.93 },
                fDensity: { value: 0.5 },
                fWeight: { value: 0.4 },
                fClamp: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                varying vec2 vUv;
                uniform float fX; uniform float fY; uniform float fExposure; uniform float fDecay; uniform float fDensity; uniform float fWeight; uniform float fClamp;
                void main() {
                    vec2 deltaTextCoord = vec2( vUv.x - fX, vUv.y - fY );
                    deltaTextCoord *= 1.0 / float( 100 ) * fDensity;
                    vec2 coord = vUv;
                    vec4 fragColor = texture2D( tDiffuse, vUv );
                    float illuminationDecay = 1.0;
                    for(int i=0; i < 75 ; i++){ // Loop n·∫∑ng ƒë·ªÉ t·∫°o tia s√°ng m∆∞·ª£t
                        coord -= deltaTextCoord;
                        vec4 texel = texture2D( tDiffuse, coord );
                        texel *= illuminationDecay * fWeight;
                        fragColor += texel;
                        illuminationDecay *= fDecay;
                    }
                    gl_FragColor = fragColor * fExposure;
                }
            `
        };
        const godRaysPass = new ShaderPass(new THREE.ShaderMaterial(godRaysShader));
        godRaysPass.needsSwap = true;
        godRaysPass.enabled = false; // M·∫∑c ƒë·ªãnh t·∫Øt (Low setting)

        // --- N√ÇNG C·∫§P: Sharpen Shader (L√†m n√©t h√¨nh ·∫£nh c·ª±c ƒë·∫°i) ---
        const SharpenShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "amount": { value: 0.3 }, // ƒê·ªô s·∫Øc n√©t (0.0 - 1.0)
                "resolution": { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float amount;
                uniform vec2 resolution;
                varying vec2 vUv;
                void main() {
                    vec2 step = 1.0 / resolution;
                    vec4 color = texture2D( tDiffuse, vUv );
                    vec4 colorLeft = texture2D( tDiffuse, vUv + vec2( -step.x, 0.0 ) );
                    vec4 colorRight = texture2D( tDiffuse, vUv + vec2( step.x, 0.0 ) );
                    vec4 colorTop = texture2D( tDiffuse, vUv + vec2( 0.0, step.y ) );
                    vec4 colorBottom = texture2D( tDiffuse, vUv + vec2( 0.0, -step.y ) );
                    vec4 sum = color * 5.0 - colorLeft - colorRight - colorTop - colorBottom;
                    gl_FragColor = mix(color, sum, amount);
                }
            `
        };
        const sharpenPass = new ShaderPass(new THREE.ShaderMaterial(SharpenShader));
        sharpenPass.enabled = false; // M·∫∑c ƒë·ªãnh t·∫Øt (Low setting)

        // --- N√ÇNG C·∫§P: Lens Dirt Effect (B·ª•i ·ªëng k√≠nh) ---
        function createDirtTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 512, 512);
            
            // V·∫Ω c√°c ƒë·ªëm b·ª•i/b·∫©n ng·∫´u nhi√™n
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const r = Math.random() * 30 + 5;
                const opacity = Math.random() * 0.2 + 0.05;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                grad.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }

        const LensDirtShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "tDirt": { value: createDirtTexture() },
                "intensity": { value: 2.0 }
            },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
            fragmentShader: `uniform sampler2D tDiffuse; uniform sampler2D tDirt; uniform float intensity; varying vec2 vUv; void main() { vec4 texel = texture2D( tDiffuse, vUv ); vec4 dirt = texture2D( tDirt, vUv ); float luminance = dot(texel.rgb, vec3(0.2126, 0.7152, 0.0722)); gl_FragColor = texel + (dirt * texel * smoothstep(0.2, 0.8, luminance) * intensity); }`
        };
        const lensDirtPass = new ShaderPass(new THREE.ShaderMaterial(LensDirtShader));
        lensDirtPass.enabled = false;

        // --- T√çNH NƒÇNG M·ªöI: Scanner Effect (Qu√©t kh√¥ng gian) ---
        const ScannerShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "uTime": { value: 0 },
                "uColor": { value: new THREE.Color(0x00ffff) },
                "uWidth": { value: 0.05 } // ƒê·ªô r·ªông ch√πm qu√©t
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float uTime;
                uniform vec3 uColor;
                uniform float uWidth;
                varying vec2 vUv;
                
                void main() {
                    vec4 texel = texture2D( tDiffuse, vUv );
                    
                    // T√≠nh to√°n v·ªã tr√≠ qu√©t (ch·∫°y t·ª´ -0.5 ƒë·∫øn 1.5)
                    float scanPos = uTime * 1.5 - 0.25;
                    
                    // T·∫°o ƒë·ªô cong nh·∫π cho v·∫°ch qu√©t gi·ªëng nh∆∞ ƒëang qu√©t kh·ªëi c·∫ßu
                    float curve = sin(vUv.y * 3.14159) * 0.1;
                    float dist = abs(vUv.x - scanPos - curve);
                    
                    if (dist < uWidth) {
                        float intensity = 1.0 - (dist / uWidth);
                        intensity = pow(intensity, 2.0); // L√†m m·ªÅm bi√™n
                        float scanline = sin(vUv.y * 500.0) * 0.1; // S·ªçc ngang
                        vec3 scanColor = uColor * (intensity + scanline);
                        gl_FragColor = vec4(texel.rgb + scanColor, texel.a);
                    } else {
                        gl_FragColor = texel;
                    }
                }
            `
        };
        const scannerPass = new ShaderPass(new THREE.ShaderMaterial(ScannerShader));
        scannerPass.enabled = false;

        // --- T√çNH NƒÇNG M·ªöI: Glitch Pass (Hi·ªáu ·ª©ng nhi·ªÖu s√≥ng) ---
        const glitchPass = new GlitchPass();
        glitchPass.enabled = false; // M·∫∑c ƒë·ªãnh t·∫Øt
        glitchPass.goWild = false;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(ssaoPass); // Th√™m SSAO v√†o pipeline
        composer.addPass(godRaysPass); // Th√™m God Rays sau SSAO
        composer.addPass(afterimagePass);
        composer.addPass(bloomPass);
        composer.addPass(lensDirtPass); // Th√™m Lens Dirt sau Bloom
        composer.addPass(bokehPass);
        composer.addPass(effectFilm);
        composer.addPass(effectShift);
        composer.addPass(sharpenPass); // Th√™m Sharpen v√†o cu·ªëi c√πng
        composer.addPass(scannerPass); // Scanner ƒë√® l√™n
        composer.addPass(glitchPass); // Glitch ƒë√® l√™n t·∫•t c·∫£

        // --- N√ÇNG C·∫§P: Real-time Reflections (CubeCamera) ---
        // Render c·∫£nh xung quanh v√†o texture ƒë·ªÉ v·∫≠t th·ªÉ ph·∫£n chi·∫øu (R·∫•t n·∫∑ng cho GPU)
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024); // TƒÉng ƒë·ªô ph√¢n gi·∫£i ph·∫£n chi·∫øu l√™n 1024 (Si√™u n√©t)
        cubeRenderTarget.texture.type = THREE.HalfFloatType;
        const cubeCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);
        scene.add(cubeCamera);

        // 4. T·∫°o v·∫≠t th·ªÉ ch√≠nh: Complex Torus Knot
        // L·ªõp b√™n trong (Solid)
        const geometry = new THREE.TorusKnotGeometry(10, 3, 300, 32); // M·∫∑c ƒë·ªãnh Low Poly
        const material = new THREE.MeshPhysicalMaterial({ 
            color: 0x156289, 
            roughness: 0.05, // B√≥ng lo√°ng ƒë·ªÉ ph·∫£n chi·∫øu r√µ n√©t
            metalness: 1.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            flatShading: false,
            envMap: cubeRenderTarget.texture // √Åp d·ª•ng texture ph·∫£n chi·∫øu th·ªùi gian th·ª±c
        });
        const torusKnot = new THREE.Mesh(geometry, material);
        torusKnot.castShadow = true;
        torusKnot.receiveShadow = true;
        scene.add(torusKnot);

        // L·ªõp b√™n ngo√†i (Wireframe)
        const wireframeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.1 }); // Gi·∫£m opacity ƒë·ªÉ nh√¨n r√µ l√µi
        const wireframeMesh = new THREE.Mesh(geometry, wireframeMat);
        wireframeMesh.scale.setScalar(1.05); // L·ªõn h∆°n m·ªôt ch√∫t ƒë·ªÉ bao b·ªçc
        torusKnot.add(wireframeMesh);

        // --- N√ÇNG C·∫§P: Quantum Core (L√µi l∆∞·ª£ng t·ª≠ trung t√¢m) ---
        // M·ªôt kh·ªëi c·∫ßu d√¢y c·ª±c k·ª≥ chi ti·∫øt xoay nhanh ·ªü gi·ªØa
        const coreGeo = new THREE.IcosahedronGeometry(5, 6); // Detail level 6 = r·∫•t nhi·ªÅu tam gi√°c
        const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 });
        const quantumCore = new THREE.Mesh(coreGeo, coreMat);
        scene.add(quantumCore);

        // --- T√çNH NƒÇNG M·ªöI: Hologram Text (VƒÉn b·∫£n 3D) ---
        const holoGroup = new THREE.Group();
        scene.add(holoGroup);

        const fontLoader = new FontLoader();
        // Load font t·ª´ URL CDN
        fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
            const texts = ["QUANTUM", "CORE", "SYSTEM", "STABLE"];
            const textMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.6,
                wireframe: true, // Hi·ªáu ·ª©ng khung d√¢y hologram
                side: THREE.DoubleSide
            });

            texts.forEach((str, i) => {
                const textGeo = new TextGeometry(str, {
                    font: font,
                    size: 1.5,
                    height: 0.1, // ƒê·ªô d√†y
                    curveSegments: 4,
                    bevelEnabled: false
                });
                
                // CƒÉn gi·ªØa vƒÉn b·∫£n
                textGeo.computeBoundingBox();
                const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
                textGeo.translate(centerOffset, 0, 0);

                const textMesh = new THREE.Mesh(textGeo, textMat);
                
                // X·∫øp th√†nh v√≤ng tr√≤n quanh l√µi
                const angle = (i / texts.length) * Math.PI * 2;
                const radius = 12; // B√°n k√≠nh qu·ªπ ƒë·∫°o
                textMesh.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                textMesh.lookAt(0, 0, 0); 
                textMesh.rotation.y += Math.PI; // Quay ng∆∞·ª£c l·∫°i ƒë·ªÉ m·∫∑t ch·ªØ h∆∞·ªõng ra ngo√†i

                holoGroup.add(textMesh);
            });
        });

        // --- N√ÇNG C·∫§P: Glass Shield (L·ªõp khi√™n th·ªßy tinh kh√∫c x·∫°) ---
        // V·∫≠t li·ªáu v·∫≠t l√Ω v·ªõi t√≠nh ch·∫•t kh√∫c x·∫° v√† t√°n s·∫Øc √°nh s√°ng (R·∫•t n·∫∑ng x·ª≠ l√Ω)
        const glassGeo = new THREE.IcosahedronGeometry(7, 6); // TƒÉng detail l√™n 6 (R·∫•t m·ªãn)
        const glassMat = new THREE.MeshPhysicalMaterial({
            roughness: 0.1,
            transmission: 0.95, // ƒê·ªô trong su·ªët (Glass)
            thickness: 1.5,
            ior: 1.5, // Ch·ªâ s·ªë kh√∫c x·∫°
            iridescence: 1.0, // Hi·ªáu ·ª©ng x√† ph√≤ng
            clearcoat: 1.0
        });
        const glassSphere = new THREE.Mesh(glassGeo, glassMat);
        scene.add(glassSphere);

        // --- N√ÇNG C·∫§P: Th√™m c√°c v√≤ng nh·∫´n xoay quanh (Gyroscope effect) ---
        const rings = [];
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xff0080, wireframe: true, transparent: true, opacity: 0.5 });
        for (let i = 0; i < 3; i++) {
            const ringGeo = new THREE.TorusGeometry(16 + (i * 4), 0.2, 16, 100);
            const ring = new THREE.Mesh(ringGeo, ringMat);
            rings.push(ring);
            scene.add(ring);
        }

        // --- N√ÇNG C·∫§P: Shader Material Object (Qu·∫£ c·∫ßu bi·∫øn d·∫°ng) ---
        // S·ª≠ d·ª•ng GLSL Shader t√πy ch·ªânh ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng s√≥ng bi·∫øn d·∫°ng ph·ª©c t·∫°p
        const blobGeo = new THREE.IcosahedronGeometry(25, 6); // TƒÉng detail l√™n 6
        const blobMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0xaa00ff) }
            },
            vertexShader: `
                uniform float uTime;
                varying vec3 vNormal;
                void main() {
                    vNormal = normal;
                    vec3 pos = position;
                    // Bi·∫øn d·∫°ng ƒë·ªânh d·ª±a tr√™n s√≥ng sin/cos ƒëa chi·ªÅu
                    float distortion = sin(pos.x * 0.1 + uTime) * cos(pos.y * 0.1 + uTime) * sin(pos.z * 0.1 + uTime);
                    pos += normal * distortion * 5.0;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                varying vec3 vNormal;
                void main() {
                    // Hi·ªáu ·ª©ng ph√°t s√°ng c·∫°nh (Fresnel-like)
                    float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                    gl_FragColor = vec4(uColor * intensity + vec3(0.0, 0.1, 0.2), 0.3);
                }
            `,
            wireframe: true,
            transparent: true,
            side: THREE.DoubleSide
        });
        const blob = new THREE.Mesh(blobGeo, blobMat);
        scene.add(blob);

        // --- N√ÇNG C·∫§P: Th√™m c√°c kh·ªëi tinh th·ªÉ tr√¥i n·ªïi ---
        const crystals = [];
        const crystalGeo = new THREE.OctahedronGeometry(1);
        const crystalMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5, flatShading: true });
        for (let i = 0; i < 30; i++) {
            const crystal = new THREE.Mesh(crystalGeo, crystalMat);
            crystal.position.set((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80);
            crystals.push({ mesh: crystal, speed: Math.random() * 0.02 + 0.01, offset: Math.random() * 100 });
            scene.add(crystal);
        }

        // --- N√ÇNG C·∫§P: Debris Field (M·∫£nh v·ª° kh√¥ng gian - InstancedMesh) ---
        // T·∫°o h√†ng ng√†n kh·ªëi l·∫≠p ph∆∞∆°ng nh·ªè xoay quanh (Si√™u n·∫∑ng cho CPU/GPU)
        const debrisCount = 2000; // M·∫∑c ƒë·ªãnh Low (2000)
        const debrisGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const debrisMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.4, metalness: 0.6 });
        const debrisMesh = new THREE.InstancedMesh(debrisGeo, debrisMat, debrisCount);
        debrisMesh.castShadow = true;
        debrisMesh.receiveShadow = true;
        
        const dummy = new THREE.Object3D();
        const debrisData = []; // L∆∞u d·ªØ li·ªáu ƒë·ªÉ animate t·ª´ng m·∫£nh

        for (let i = 0; i < debrisCount; i++) {
            dummy.position.set((Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150);
            dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            dummy.updateMatrix();
            debrisMesh.setMatrixAt(i, dummy.matrix);
            debrisData.push({ 
                rotSpeed: (Math.random() - 0.5) * 0.05, 
                initialPos: dummy.position.clone(),
                offset: Math.random() * 100,
                velocity: new THREE.Vector3(), // V·∫≠n t·ªëc v·∫≠t l√Ω
                physicsPos: new THREE.Vector3() // V·ªã tr√≠ v·∫≠t l√Ω t√≠ch l≈©y
            });
        }
        scene.add(debrisMesh);

        // --- N√ÇNG C·∫§P: Vortex (C∆°n l·ªëc Tetrahedrons) ---
        const vortexCount = 1000; // M·∫∑c ƒë·ªãnh Low (1000)
        const vortexGeo = new THREE.TetrahedronGeometry(0.5);
        const vortexMat = new THREE.MeshStandardMaterial({ color: 0xff00ff, roughness: 0.2, metalness: 0.8 });
        const vortexMesh = new THREE.InstancedMesh(vortexGeo, vortexMat, vortexCount);
        vortexMesh.castShadow = true;
        vortexMesh.receiveShadow = true;

        const vortexDummy = new THREE.Object3D();
        const vortexData = [];
        for(let i=0; i<vortexCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 50;
            const y = (Math.random() - 0.5) * 60;
            vortexData.push({ angle, radius, y, speed: 0.01 + Math.random() * 0.02 });
            vortexDummy.position.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
            vortexDummy.updateMatrix();
            vortexMesh.setMatrixAt(i, vortexDummy.matrix);
        }
        scene.add(vortexMesh);

        // --- N√ÇNG C·∫§P: Cyber Floor (S√†n nh√† chuy·ªÉn ƒë·ªông) ---
        const floorSize = 20;
        const floorCount = floorSize * floorSize;
        const floorGeo = new THREE.BoxGeometry(4, 10, 4);
        floorGeo.translate(0, 5, 0); // ƒê·∫∑t t√¢m xoay xu·ªëng ƒë√°y
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9, roughness: 0.1 });
        const floorMesh = new THREE.InstancedMesh(floorGeo, floorMat, floorCount);
        floorMesh.receiveShadow = true;
        floorMesh.position.y = -50;
        
        const floorDummy = new THREE.Object3D();
        for(let i=0; i<floorSize; i++) {
            for(let j=0; j<floorSize; j++) {
                const index = i * floorSize + j;
                floorDummy.position.set((i - floorSize/2) * 5, 0, (j - floorSize/2) * 5);
                floorDummy.updateMatrix();
                floorMesh.setMatrixAt(index, floorDummy.matrix);
            }
        }
        scene.add(floorMesh);

        // --- N√ÇNG C·∫§P: Satellites (V·ªá tinh nh√¢n t·∫°o) ---
        const satellites = [];
        const satGeoCore = new THREE.DodecahedronGeometry(1);
        const satGeoPanel = new THREE.BoxGeometry(0.2, 3, 6);
        const satMat = new THREE.MeshStandardMaterial({ color: 0x00aaff, metalness: 1, roughness: 0.2 });

        for(let i=0; i<6; i++) {
            const satGroup = new THREE.Group();
            const core = new THREE.Mesh(satGeoCore, satMat);
            const panel1 = new THREE.Mesh(satGeoPanel, satMat);
            panel1.position.x = -2;
            const panel2 = new THREE.Mesh(satGeoPanel, satMat);
            panel2.position.x = 2;
            satGroup.add(core, panel1, panel2);
            satGroup.castShadow = true;
            
            satGroup.userData = {
                angle: Math.random() * Math.PI * 2,
                radius: 40 + Math.random() * 20,
                speed: 0.005 + Math.random() * 0.01,
                yOffset: (Math.random() - 0.5) * 20
            };
            scene.add(satGroup);
            satellites.push(satGroup);
        }

        // --- N√ÇNG C·∫§P: Data Streams (4 chu·ªói xo·∫Øn DNA kh·ªïng l·ªì) ---
        const streamCount = 4000;
        const streamGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const streamMat = new THREE.MeshBasicMaterial({ color: 0x00ffaa, wireframe: false });
        const streamMesh = new THREE.InstancedMesh(streamGeo, streamMat, streamCount);
        
        const streamDummy = new THREE.Object3D();
        const streamData = [];
        
        for(let i=0; i<streamCount; i++) {
            // Chia th√†nh 4 nh√°nh
            const branch = i % 4;
            const t = Math.random() * 100; // ƒê·ªô cao
            const angle = t * 0.5 + (branch * (Math.PI / 2));
            const radius = 60;
            
            streamDummy.position.set(Math.cos(angle) * radius, (t - 50) * 2, Math.sin(angle) * radius);
            streamDummy.updateMatrix();
            streamMesh.setMatrixAt(i, streamDummy.matrix);
            
            streamData.push({ branch, t, speed: 0.1 + Math.random() * 0.1, radius });
        }
        scene.add(streamMesh);

        // --- N√ÇNG C·∫§P: Dyson Sphere Cage (L·ªìng bao quanh v≈© tr·ª•) ---
        const cageGeo = new THREE.IcosahedronGeometry(200, 2);
        const cageMat = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: true, transparent: true, opacity: 0.3 });
        const cageMesh = new THREE.Mesh(cageGeo, cageMat);
        scene.add(cageMesh);

        // L·ªõp l·ªìng th·ª© 2 nh·ªè h∆°n, xoay ng∆∞·ª£c chi·ªÅu
        const cageGeo2 = new THREE.IcosahedronGeometry(180, 1);
        const cageMat2 = new THREE.MeshBasicMaterial({ color: 0x666666, wireframe: true, transparent: true, opacity: 0.2 });
        const cageMesh2 = new THREE.Mesh(cageGeo2, cageMat2);
        scene.add(cageMesh2);

        // --- N√ÇNG C·∫§P: Hyperspace Tunnel (ƒê∆∞·ªùng h·∫ßm si√™u kh√¥ng gian) ---
        const tunnelGeo = new THREE.CylinderGeometry(100, 100, 1000, 32, 5, true);
        const tunnelMat = new THREE.MeshBasicMaterial({ 
            color: 0x001133, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.15,
            side: THREE.DoubleSide
        });
        const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
        tunnel.rotation.x = Math.PI / 2;
        scene.add(tunnel);

        // --- N√ÇNG C·∫§P: Volumetric Fog (S∆∞∆°ng m√π th·ªÉ t√≠ch di chuy·ªÉn) ---
        const fogGeo = new THREE.BoxGeometry(300, 300, 300);
        const fogMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0x001133) } // M√†u xanh ƒëen b√≠ ·∫©n
            },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec3 vPosition;

                // H√†m noise ƒë∆°n gi·∫£n t·ª´ sin/cos ƒë·ªÉ t·∫°o ƒë√°m m√¢y
                float getNoise(vec3 p) {
                    return sin(p.x * 0.05 + uTime * 0.5) * sin(p.y * 0.05 + uTime * 0.3) * sin(p.z * 0.05 + uTime * 0.2);
                }

                void main() {
                    float n = getNoise(vPosition);
                    // T·∫°o c√°c m·∫£ng s∆∞∆°ng m√π tr√¥i n·ªïi, m·ªù ·∫£o
                    float alpha = smoothstep(0.0, 0.8, n) * 0.05; // Gi·∫£m ƒë·ªô ƒë·∫∑c c·ªßa s∆∞∆°ng m√π
                    
                    // L√†m m·ªù d·∫ßn ·ªü c√°c c·∫°nh xa ƒë·ªÉ kh√¥ng th·∫•y khung h·ªôp
                    float dist = length(vPosition);
                    alpha *= smoothstep(150.0, 50.0, dist);

                    gl_FragColor = vec4(uColor + vec3(n * 0.1), alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const fogMesh = new THREE.Mesh(fogGeo, fogMat);
        scene.add(fogMesh);

        // --- N√ÇNG C·∫§P: Menger Sponge Fractal (C·∫•u tr√∫c ph√¢n h√¨nh) ---
        // T·∫°o m·ªôt kh·ªëi fractal ph·ª©c t·∫°p b·∫±ng InstancedMesh
        const spongeCount = 8000; // Level 3: 20^3 = 8000 kh·ªëi
        const spongeGeo = new THREE.BoxGeometry(1, 1, 1);
        const spongeMat = new THREE.MeshStandardMaterial({ 
            color: 0xcc3333, 
            roughness: 0.3, 
            metalness: 0.8 
        });
        const spongeMesh = new THREE.InstancedMesh(spongeGeo, spongeMat, spongeCount);
        spongeMesh.castShadow = true;
        spongeMesh.receiveShadow = true;

        const spongeDummy = new THREE.Object3D();
        let spongeIdx = 0;

        function generateMenger(x, y, z, size, level) {
            if (level === 0) {
                spongeDummy.position.set(x, y, z);
                spongeDummy.scale.set(size, size, size);
                spongeDummy.updateMatrix();
                if (spongeIdx < spongeCount) spongeMesh.setMatrixAt(spongeIdx++, spongeDummy.matrix);
                return;
            }
            const newSize = size / 3;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        let zeros = 0;
                        if (dx === 0) zeros++;
                        if (dy === 0) zeros++;
                        if (dz === 0) zeros++;
                        if (zeros < 2) {
                            generateMenger(x + dx * newSize, y + dy * newSize, z + dz * newSize, newSize, level - 1);
                        }
                    }
                }
            }
        }
        generateMenger(0, 0, 0, 180, 3); // T·∫°o fractal k√≠ch th∆∞·ªõc 180
        scene.add(spongeMesh);

        // --- N√ÇNG C·∫§P: Neural Network Lines (C√°c ƒë∆∞·ªùng k·∫øt n·ªëi debris) ---
        const lineCount = 500;
        const lineGeo = new THREE.BufferGeometry();
        const linePos = new Float32Array(lineCount * 2 * 3); // 2 points per line, 3 coords per point
        lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
        const lineMesh = new THREE.LineSegments(lineGeo, lineMat);
        scene.add(lineMesh);

        // --- N√ÇNG C·∫§P: Titan Structure (C·∫•u tr√∫c si√™u n·∫∑ng High-Poly) ---
        // Geometry c·ª±c k·ª≥ chi ti·∫øt v·ªõi h√†ng trƒÉm ng√†n tam gi√°c
        const titanGeo = new THREE.TorusKnotGeometry(60, 2, 200, 32, 2, 5); // M·∫∑c ƒë·ªãnh Low Poly
        const titanMat = new THREE.MeshStandardMaterial({
            color: 0xffd700, // V√†ng kim lo·∫°i
            metalness: 1.0,
            roughness: 0.2,
            wireframe: true, // Wireframe ƒë·ªÉ th·∫•y ƒë·ªô d√†y ƒë·∫∑c c·ªßa l∆∞·ªõi
            transparent: true,
            opacity: 0.15
        });
        const titanMesh = new THREE.Mesh(titanGeo, titanMat);
        scene.add(titanMesh);

        // --- N√ÇNG C·∫§P: Nano Swarm (B·∫ßy ƒë√†n Nano - 10,000 v·∫≠t th·ªÉ ƒë·ªông) ---
        const swarmCount = 2000; // M·∫∑c ƒë·ªãnh Low (2000)
        const swarmGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const swarmMat = new THREE.MeshPhysicalMaterial({
            color: 0x00ffff,
            metalness: 0.9,
            roughness: 0.1,
            clearcoat: 1.0
        });
        const swarmMesh = new THREE.InstancedMesh(swarmGeo, swarmMat, swarmCount);
        swarmMesh.castShadow = true;
        swarmMesh.receiveShadow = true;
        
        const swarmDummy = new THREE.Object3D();
        const swarmData = [];
        for(let i=0; i<swarmCount; i++) {
            swarmData.push({
                x: (Math.random() - 0.5) * 300,
                z: (Math.random() - 0.5) * 300,
                speed: Math.random() * 0.02 + 0.01,
                offset: Math.random() * 100
            });
        }
        scene.add(swarmMesh);

        // --- N√ÇNG C·∫§P: Volumetric Light Beams (Lu·ªìng s√°ng th·ªÉ t√≠ch v·∫≠t l√Ω) ---
        // T·∫°o c√°c h√¨nh n√≥n √°nh s√°ng xoay quanh l√µi
        const beamGeo = new THREE.CylinderGeometry(2, 30, 200, 32, 1, true);
        const beamMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0x4488ff) }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                void main() {
                    float alpha = smoothstep(0.0, 0.2, vUv.y) * smoothstep(1.0, 0.5, vUv.y); // Fade 2 ƒë·∫ßu
                    float noise = sin(vUv.x * 20.0 + uTime * 5.0) * 0.5 + 0.5; // Hi·ªáu ·ª©ng s√≥ng √°nh s√°ng
                    alpha *= (0.3 + noise * 0.7);
                    gl_FragColor = vec4(uColor, alpha * 0.15);
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const beamMesh = new THREE.Mesh(beamGeo, beamMat);
        beamMesh.rotation.x = Math.PI / 2;
        scene.add(beamMesh);

        const beamMesh2 = beamMesh.clone();
        beamMesh2.rotation.x = Math.PI / 2;
        beamMesh2.rotation.z = Math.PI / 2;
        scene.add(beamMesh2);

        // 5. T·∫°o h·ªá th·ªëng h·∫°t (Particles/Stars)
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 10000; // M·∫∑c ƒë·ªãnh Low (10000)
        const posArray = new Float32Array(particlesCount * 3);

        for(let i = 0; i < particlesCount * 3; i++) {
            // T·∫°o v·ªã tr√≠ ng·∫´u nhi√™n trong kh√¥ng gian r·ªông
            posArray[i] = (Math.random() - 0.5) * 200; 
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.2,
            color: 0xffffff,
            transparent: true,
            opacity: 0.8,
        });
        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        // 6. √Ånh s√°ng (Lighting)
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);

        // Texture cho Lensflare
        const textureLoader = new THREE.TextureLoader();
        const textureFlare0 = textureLoader.load('https://unpkg.com/three@0.160.0/examples/textures/lensflare/lensflare0.png');
        const textureFlare3 = textureLoader.load('https://unpkg.com/three@0.160.0/examples/textures/lensflare/lensflare3.png');

        function addLensflare(light) {
            const lensflare = new Lensflare();
            lensflare.addElement(new LensflareElement(textureFlare0, 600, 0, light.color));
            lensflare.addElement(new LensflareElement(textureFlare3, 60, 0.6));
            lensflare.addElement(new LensflareElement(textureFlare3, 70, 0.7));
            lensflare.addElement(new LensflareElement(textureFlare3, 120, 0.9));
            lensflare.addElement(new LensflareElement(textureFlare3, 70, 1));
            light.add(lensflare);
        }

        const pointLight1 = new THREE.PointLight(0xff0040, 200); // Gi·∫£m c∆∞·ªùng ƒë·ªô ƒë√®n
        pointLight1.position.set(20, 20, 20);
        pointLight1.castShadow = true;
        pointLight1.shadow.mapSize.width = 512; // M·∫∑c ƒë·ªãnh Low (512)
        pointLight1.shadow.mapSize.height = 512;
        addLensflare(pointLight1);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x0040ff, 200);
        pointLight2.position.set(-20, -20, 20);
        pointLight2.castShadow = true;
        pointLight2.shadow.mapSize.width = 512;
        pointLight2.shadow.mapSize.height = 512;
        addLensflare(pointLight2);
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight(0x80ff80, 200);
        pointLight3.position.set(0, 20, -20);
        pointLight3.castShadow = true;
        pointLight3.shadow.mapSize.width = 512;
        pointLight3.shadow.mapSize.height = 512;
        addLensflare(pointLight3);
        scene.add(pointLight3);

        // Helper ƒë·ªÉ hi·ªÉn th·ªã v·ªã tr√≠ ƒë√®n (t√πy ch·ªçn, ƒë√£ t·∫Øt ƒë·ªÉ ƒë·∫πp h∆°n)
        // const sphereSize = 1;
        // scene.add(new THREE.PointLightHelper(pointLight1, sphereSize));

        // ·∫®n loading text khi ƒë√£ s·∫µn s√†ng
        document.getElementById('loading').style.opacity = 0;

        // --- T√çNH NƒÇNG M·ªöI: Hyperdrive (B∆∞·ªõc nh·∫£y kh√¥ng gian) ---
        let isWarping = false;
        let warpFactor = 0; // 0: B√¨nh th∆∞·ªùng, 1: Max t·ªëc ƒë·ªô
        const warpBtn = document.getElementById('warp-btn');

        function toggleWarp() {
            isWarping = !isWarping;
            if(isWarping) warpBtn.classList.add('active');
            else warpBtn.classList.remove('active');
            sysLog(isWarping ? "WARP DRIVE: ENGAGED" : "WARP DRIVE: DISENGAGED");
        }

        warpBtn.addEventListener('click', toggleWarp);
        
        // Ph√≠m t·∫Øt Space ƒë·ªÉ Supernova
        window.addEventListener('keydown', (e) => {
            if(e.code === 'Space') {
                triggerSupernova();
            }
        });

        // --- T√çNH NƒÇNG M·ªöI: Audio Reactivity (Ph·∫£n ·ª©ng √¢m thanh) ---
        let audioContext, analyser, dataArray;
        let audioActive = false;
        const audioBtn = document.getElementById('audio-btn');

        async function setupAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                audioActive = true;
                audioBtn.classList.add('active');
                audioBtn.innerText = "MIC ACTIVE";
                sysLog("Audio Input: Connected");
            } catch (err) {
                console.error('Audio permission denied', err);
                alert("C·∫ßn quy·ªÅn truy c·∫≠p Microphone ƒë·ªÉ k√≠ch ho·∫°t t√≠nh nƒÉng n√†y!");
            }
        }

        audioBtn.addEventListener('click', setupAudio);

        // --- T√çNH NƒÇNG M·ªöI: Gravity Control (ƒêi·ªÅu khi·ªÉn tr·ªçng l·ª±c) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const gravityPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // M·∫∑t ph·∫≥ng ·∫£o ƒë·ªÉ chi·∫øu chu·ªôt
        const gravityTarget = new THREE.Vector3();
        let isGravityActive = 0; // 0: T·∫Øt, 1: H√∫t, -1: ƒê·∫©y

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('mousedown', (event) => {
            if (event.button === 0) isGravityActive = 1; // Chu·ªôt tr√°i: H√∫t
            if (event.button === 2) isGravityActive = -1; // Chu·ªôt ph·∫£i: ƒê·∫©y
        });

        window.addEventListener('mouseup', () => {
            isGravityActive = 0;
        });
        
        // NgƒÉn menu chu·ªôt ph·∫£i hi·ªán ra
        window.addEventListener('contextmenu', event => event.preventDefault());

        // --- N√ÇNG C·∫§P: System Logger (T√≠ch h·ª£p v√†o Control Panel) ---
        const logContainer = document.getElementById('system-log-container');
        function sysLog(msg) {
            if (!logContainer) return;
            const div = document.createElement('div');
            div.className = 'log-entry';
            // Th√™m timestamp
            const time = new Date().toLocaleTimeString('en-US', {hour12: false});
            div.innerHTML = `<span style="color:#888">[${time}]</span> > ${msg.toUpperCase()}`;
            logContainer.appendChild(div);
            // T·ª± ƒë·ªông cu·ªôn xu·ªëng d∆∞·ªõi
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // AI Reaction: ƒê√¥i khi AI s·∫Ω ƒë·ªçc log h·ªá th·ªëng
            if (typeof window.triggerAiTalk === 'function' && Math.random() < 0.25) {
                 window.triggerAiTalk(msg);
            }
        }

        // Log kh·ªüi ƒë·ªông
        setTimeout(() => sysLog("System initialized"), 100);
        setTimeout(() => sysLog("GPU: " + rendererInfo.split('Angle')[0].trim()), 500);
        setTimeout(() => sysLog("Quantum Core... Online"), 1000);

        // --- T√çNH NƒÇNG M·ªöI: Draggable & Collapsible Control Panel ---
        const controlPanel = document.getElementById('control-panel');
        const panelHeader = document.getElementById('panel-header');
        const panelToggleBtn = document.getElementById('panel-toggle-btn');

        // Collapse/Expand
        panelToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // NgƒÉn s·ª± ki·ªán click lan ra header
            controlPanel.classList.toggle('collapsed');
            panelToggleBtn.innerText = controlPanel.classList.contains('collapsed') ? '+' : '-';
        });

        // Draggable
        let isDragging = false;
        let offset = { x: 0, y: 0 };

        panelHeader.addEventListener('mousedown', (e) => {
            if (e.target === panelToggleBtn) return;
            isDragging = true;
            offset.x = e.clientX - controlPanel.offsetLeft;
            offset.y = e.clientY - controlPanel.offsetTop;
            panelHeader.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            let newX = e.clientX - offset.x;
            let newY = e.clientY - offset.y;
            const maxX = window.innerWidth - controlPanel.offsetWidth;
            const maxY = window.innerHeight - controlPanel.offsetHeight;
            newX = Math.max(0, Math.min(newX, maxX));
            newY = Math.max(0, Math.min(newY, maxY));
            controlPanel.style.left = `${newX}px`;
            controlPanel.style.top = `${newY}px`;
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            panelHeader.style.cursor = 'move';
        });

        // --- T√çNH NƒÇNG M·ªöI: Effect Toggles ---
        let isReflectionsEnabled = true, isFogEnabled = true, isDebrisEnabled = true, isLinesEnabled = true;
        document.getElementById('toggle-reflections').addEventListener('change', e => { isReflectionsEnabled = e.target.checked; sysLog(`Real-time Reflections: ${isReflectionsEnabled ? 'ON' : 'OFF'}`); });
        document.getElementById('toggle-fog').addEventListener('change', e => { isFogEnabled = e.target.checked; fogMesh.visible = isFogEnabled; sysLog(`Volumetric Fog: ${isFogEnabled ? 'ON' : 'OFF'}`); });
        document.getElementById('toggle-debris').addEventListener('change', e => { isDebrisEnabled = e.target.checked; debrisMesh.visible = isDebrisEnabled; sysLog(`Debris Field: ${isDebrisEnabled ? 'ON' : 'OFF'}`); });
        document.getElementById('toggle-lines').addEventListener('change', e => { isLinesEnabled = e.target.checked; lineMesh.visible = isLinesEnabled; sysLog(`Neural Lines: ${isLinesEnabled ? 'ON' : 'OFF'}`); });

        // --- T√çNH NƒÇNG M·ªöI: Time Slider ---
        const timeSlider = document.getElementById('time-slider');
        let manualTimeScale = 1.0;
        timeSlider.addEventListener('input', (e) => {
            manualTimeScale = parseFloat(e.target.value);
        });

        // --- T√çNH NƒÇNG M·ªöI: Theme Switcher & Glitch Control ---
        const themes = {
            cyberpunk: {
                primary: 0x156289, // Blue
                fog: 0x050505,
                matrix: '#00ff00',
                lights: [0xff0040, 0x0040ff, 0x80ff80], // Pink, Blue, Green
                beam: 0x4488ff,
                blob: 0xaa00ff
            },
            matrix: {
                primary: 0x003300, // Dark Green
                fog: 0x001100,
                matrix: '#00ff00',
                lights: [0x00ff00, 0x008800, 0xccffcc], // All Green variants
                beam: 0x00ff00,
                blob: 0x00ff00
            },
            inferno: {
                primary: 0x330000, // Dark Red
                fog: 0x110000,
                matrix: '#ff0000',
                lights: [0xff0000, 0xff8800, 0xffaa00], // Red, Orange, Yellow
                beam: 0xff4400,
                blob: 0xff0000
            },
            oceanic: {
                primary: 0x0077be, // Sea Blue
                fog: 0x000510,     // Deep Blue
                matrix: '#aaddff', // Light Cyan
                lights: [0x00aaff, 0xffffff, 0x80c0ff], // Light Blue, White, Lighter Blue
                beam: 0x80c0ff,
                blob: 0x005090
            },
            vaporwave: {
                primary: 0x4a0d67, // Deep Purple
                fog: 0x0f0026,     // Dark Purple/Blue
                matrix: '#ff00ff', // Magenta
                lights: [0xff00ff, 0x00ffff, 0x9d00ff], // Magenta, Cyan, Purple
                beam: 0x00ffff,
                blob: 0xff00ff
            }
        };

        document.getElementById('theme-select').addEventListener('change', (e) => {
            const t = themes[e.target.value];
            if(!t) return;

            // C·∫≠p nh·∫≠t m√†u s·∫Øc
            scene.fog.color.setHex(t.fog);
            matrixColor = t.matrix;
            
            // V·∫≠t th·ªÉ ch√≠nh
            torusKnot.material.color.setHex(t.primary);
            
            // ƒê√®n
            pointLight1.color.setHex(t.lights[0]);
            pointLight2.color.setHex(t.lights[1]);
            pointLight3.color.setHex(t.lights[2]);

            // Shader materials
            fogMat.uniforms.uColor.value.setHex(t.fog); // S∆∞∆°ng m√π theo m√†u n·ªÅn
            beamMat.uniforms.uColor.value.setHex(t.beam);
            blobMat.uniforms.uColor.value.setHex(t.blob);

            sysLog(`Theme changed to: ${e.target.value.toUpperCase()}`);
        });

        document.getElementById('glitch-btn').addEventListener('click', () => {
            glitchPass.enabled = !glitchPass.enabled;
            sysLog(glitchPass.enabled ? "SYSTEM FAILURE: GLITCH ACTIVE" : "SYSTEM STABILIZED");
        });

        // --- T√çNH NƒÇNG M·ªöI: Black Hole ---
        let isBlackHoleActive = false;
        const blackHoleBtn = document.getElementById('blackhole-btn');
        
        // Visual: Black Sphere
        const blackHoleGeo = new THREE.SphereGeometry(15, 32, 32);
        const blackHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackHoleMesh = new THREE.Mesh(blackHoleGeo, blackHoleMat);
        blackHoleMesh.visible = false;
        scene.add(blackHoleMesh);

        // Visual: Accretion Disk (Ring)
        const diskGeo = new THREE.RingGeometry(18, 40, 64);
        const diskMat = new THREE.MeshBasicMaterial({ 
            color: 0xff4400, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.5,
            blending: THREE.AdditiveBlending
        });
        const accretionDisk = new THREE.Mesh(diskGeo, diskMat);
        accretionDisk.rotation.x = Math.PI / 2;
        accretionDisk.visible = false;
        scene.add(accretionDisk);

        blackHoleBtn.addEventListener('click', () => {
            isBlackHoleActive = !isBlackHoleActive;
            if(isBlackHoleActive) {
                blackHoleBtn.classList.add('active');
                blackHoleBtn.innerText = "BLACK HOLE: ACTIVE";
                blackHoleMesh.visible = true;
                accretionDisk.visible = true;
                quantumCore.visible = false;
                sysLog("WARNING: SINGULARITY DETECTED");
            } else {
                blackHoleBtn.classList.remove('active');
                blackHoleBtn.innerText = "ACTIVATE BLACK HOLE";
                blackHoleMesh.visible = false;
                accretionDisk.visible = false;
                quantumCore.visible = true;
                sysLog("Singularity Collapsed");
            }
        });

        // --- T√çNH NƒÇNG M·ªöI: Supernova ---
        const supernovaBtn = document.getElementById('supernova-btn');
        
        // Visual: Expanding Star Core
        const supernovaGeo = new THREE.SphereGeometry(1, 32, 32);
        const supernovaMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0 });
        const supernovaMesh = new THREE.Mesh(supernovaGeo, supernovaMat);
        scene.add(supernovaMesh);

        let supernovaActive = false;
        let supernovaTime = 0;

        function triggerSupernova() {
            if(supernovaActive) return;
            supernovaActive = true;
            supernovaTime = 0;
            supernovaMesh.visible = true;
            supernovaMat.opacity = 1;
            supernovaMesh.scale.setScalar(1);
            
            sysLog("WARNING: SUPERNOVA DETECTED");
            
            // Physics push (ƒê·∫©y c·ª±c m·∫°nh m·ªçi v·∫≠t th·ªÉ ra xa)
             for (let i = 0; i < debrisCount; i++) {
                const data = debrisData[i];
                const currentPos = data.initialPos.clone().add(data.physicsPos);
                const dist = currentPos.length();
                
                const forceDir = currentPos.normalize();
                const force = 1000.0 / (1 + dist * 0.05); // L·ª±c n·ªï c·ª±c l·ªõn
                data.velocity.add(forceDir.multiplyScalar(force));
            }
        }

        supernovaBtn.addEventListener('click', triggerSupernova);

        // --- T√çNH NƒÇNG M·ªöI: Scanner Logic ---
        const scanBtn = document.getElementById('scan-btn');
        let isScanning = false;
        let scanTime = 0;

        scanBtn.addEventListener('click', () => {
            if(isScanning) return;
            isScanning = true;
            scanTime = 0;
            scannerPass.enabled = true;
            sysLog("INITIATING SYSTEM SCAN...");
        });

        // --- T√çNH NƒÇNG M·ªöI: Digital Rain on Objects ---
        const rainBtn = document.getElementById('rain-btn');
        let isRainActive = false;
        
        const MatrixObjectShader = {
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0x00ff00) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec2 vUv;
                
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    float rows = 30.0; // M·∫≠t ƒë·ªô d√≤ng
                    vec2 ipos = floor(vUv * rows);
                    
                    // T·ªëc ƒë·ªô r∆°i ng·∫´u nhi√™n cho m·ªói c·ªôt
                    float speed = 5.0 + random(vec2(ipos.x, 0.0)) * 5.0;
                    float y = floor(vUv.y * rows + uTime * speed);
                    
                    // K√Ω t·ª± ng·∫´u nhi√™n (gi·∫£ l·∫≠p b·∫±ng noise)
                    float char = step(0.5, random(vec2(ipos.x, y)));
                    
                    // Hi·ªáu ·ª©ng m·ªù d·∫ßn (Trail)
                    float trail = fract(vUv.y * 5.0 + uTime * speed * 0.2);
                    trail = pow(trail, 3.0);

                    vec3 finalColor = uColor * char * trail;
                    float alpha = length(finalColor);
                    
                    gl_FragColor = vec4(finalColor, alpha * 0.9);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        };

        const matrixObjMat = new THREE.ShaderMaterial(MatrixObjectShader);
        const originalTorusMat = torusKnot.material;
        const originalTitanMat = titanMesh.material;
        const originalDebrisMat = debrisMesh.material;

        rainBtn.addEventListener('click', () => {
            isRainActive = !isRainActive;
            if(isRainActive) {
                torusKnot.material = matrixObjMat;
                titanMesh.material = matrixObjMat;
                debrisMesh.material = matrixObjMat;
                rainBtn.classList.add('active');
                rainBtn.innerText = "DIGITAL RAIN: ON";
                sysLog("MATRIX CAMOUFLAGE: ACTIVE");
            } else {
                torusKnot.material = originalTorusMat;
                titanMesh.material = originalTitanMat;
                debrisMesh.material = originalDebrisMat;
                rainBtn.classList.remove('active');
                rainBtn.innerText = "DIGITAL RAIN";
                sysLog("MATRIX CAMOUFLAGE: DISABLED");
            }
        });

        // --- T√çNH NƒÇNG M·ªöI: Wireframe Mode ---
        const wireframeBtn = document.getElementById('wireframe-btn');
        let isWireframe = false;

        wireframeBtn.addEventListener('click', () => {
            isWireframe = !isWireframe;
            
            if (isWireframe) {
                wireframeBtn.classList.add('active');
                wireframeBtn.innerText = "WIREFRAME: ON";
                sysLog("VISUAL SYSTEM: WIREFRAME MODE ENGAGED");

                scene.traverse((obj) => {
                    if (obj.isMesh && obj !== particlesMesh) {
                        // L∆∞u material g·ªëc
                        if (!obj.userData.originalMat) {
                            obj.userData.originalMat = obj.material;
                        }
                        
                        // L·∫•y m√†u g·ªëc ho·∫∑c d√πng m√†u m·∫∑c ƒë·ªãnh
                        let color = 0x00ff00;
                        if (obj.material.color) color = obj.material.color;
                        else if (obj.material.uniforms && obj.material.uniforms.uColor) color = obj.material.uniforms.uColor.value;

                        obj.material = new THREE.MeshBasicMaterial({
                            color: color,
                            wireframe: true,
                            transparent: true,
                            opacity: 0.8
                        });
                    }
                });
                scene.fog.density = 0; // T·∫Øt s∆∞∆°ng m√π
            } else {
                wireframeBtn.classList.remove('active');
                wireframeBtn.innerText = "WIREFRAME MODE";
                sysLog("VISUAL SYSTEM: STANDARD MODE RESTORED");

                scene.traverse((obj) => {
                    if (obj.isMesh && obj.userData.originalMat) {
                        obj.material = obj.userData.originalMat;
                    }
                });
                scene.fog.density = 0.002; // Kh√¥i ph·ª•c s∆∞∆°ng m√π
            }
        });

        // --- T√çNH NƒÇNG M·ªöI: Energy Pulse (Audio Reactive) ---
        const pulseGroup = new THREE.Group();
        scene.add(pulseGroup);
        const audioPulses = [];
        let lastPulseTime = 0;
        const pulseCooldown = 200; // ms, th·ªùi gian ch·ªù gi·ªØa c√°c xung
        
        // Bi·∫øn ki·ªÉm so√°t tr·∫°ng th√°i game ƒë·ªÉ t·ªëi ∆∞u hi·ªáu nƒÉng (M·∫∑c ƒë·ªãnh t·∫Øt khi ·ªü trang ch·ªß)
        let isGameActive = false;

        function spawnAudioPulse(color) {
            const pulseGeo = new THREE.RingGeometry(1, 1.5, 64);
            const pulseMat = new THREE.MeshBasicMaterial({
                color: color || 0x00ffff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const pulseMesh = new THREE.Mesh(pulseGeo, pulseMat);
            audioPulses.push({
                mesh: pulseMesh,
                startTime: Date.now()
            });
            pulseGroup.add(pulseMesh);
        }

        // --- T√çNH NƒÇNG M·ªöI: System Diagnostics ---
        let isDiagnosing = false;
        window.runDiagnostics = function() {
            if (isDiagnosing || isGameActive) return; // Kh√¥ng ch·∫°y khi ƒëang test ho·∫∑c ƒë√£ v√†o game
            isDiagnosing = true;

            const diagCard = document.querySelector('.diag-card');
            const originalCardHTML = diagCard.innerHTML;
            diagCard.style.pointerEvents = 'none'; // V√¥ hi·ªáu h√≥a click khi ƒëang ch·∫°y
            diagCard.innerHTML = `
                <div class="card-icon" style="animation: spin 1.5s linear infinite;">üì°</div>
                <h1>SYSTEM<br>DIAGNOSTICS</h1>
                <p style="color: #ffa500;">RUNNING...</p>
                <div style="margin-top: 20px; font-size: 10px; opacity: 0.5;">ANALYZING...</div>
            `;

            const scanner = document.createElement('div');
            scanner.id = 'diag-scanner';
            document.body.appendChild(scanner);
            scanner.style.animation = 'screenScan 4s linear';

            const diagMessages = [
                "INITIATING DIAGNOSTICS...",
                "PINGING CORE SYSTEMS... OK",
                "ANALYZING PARTICLE FIELD... STABLE",
                "VERIFYING RENDER PIPELINE... NOMINAL",
                "CHECKING WORKER THREADS... OK",
                "ALL SYSTEMS GREEN. DIAGNOSTICS COMPLETE."
            ];
            
            const typeElement = document.getElementById('typewriter-text');
            typeElement.textContent = '';
            typeElement.style.animation = 'none'; // T·∫Øt hi·ªáu ·ª©ng nh√°y
            typeElement.style.borderRight = '2px solid #555'; // Gi·ªØ con tr·ªè

            let msgIndex = 0;

            function typeNextMessage() {
                if (msgIndex >= diagMessages.length) {
                    setTimeout(() => {
                        isDiagnosing = false;
                        diagCard.innerHTML = originalCardHTML;
                        diagCard.style.pointerEvents = 'auto';
                        if(scanner) scanner.remove();
                        
                        typeElement.textContent = "SYSTEM READY";
                        typeElement.style.animation = "blinkCursor 1s step-end infinite";
                    }, 1500);
                    return;
                }
                typeElement.innerHTML += (msgIndex > 0 ? '<br>' : '') + '> ' + diagMessages[msgIndex];
                msgIndex++;
                setTimeout(typeNextMessage, 650); // Th·ªùi gian gi·ªØa m·ªói d√≤ng
            }
            setTimeout(typeNextMessage, 200);
        };

        // --- T√çNH NƒÇNG M·ªöI: Credits ---
        window.showCredits = function() {
            const overlay = document.getElementById('credits-overlay');
            overlay.style.display = 'block';
            overlay.scrollTop = 0; // Lu√¥n b·∫Øt ƒë·∫ßu t·ª´ ƒë·∫ßu khi m·ªü
        };
        window.hideCredits = function() {
            document.getElementById('credits-overlay').style.display = 'none';
        };

        // --- T√çNH NƒÇNG M·ªöI: AI Settings ---
        window.showAiSettings = function() {
            const overlay = document.getElementById('ai-settings-overlay');
            overlay.style.display = 'block';
            overlay.scrollTop = 0;
        };
        window.hideAiSettings = function() {
            document.getElementById('ai-settings-overlay').style.display = 'none';
        };

        // --- T√çNH NƒÇNG M·ªöI: Landing & CPU Test Logic ---
        window.startBenchmarkMode = function() {
            isGameActive = true; // K√≠ch ho·∫°t render 3D khi b·∫Øt ƒë·∫ßu
            
            const landing = document.getElementById('landing-screen');
            landing.style.opacity = 0;
            landing.style.transform = 'scale(5)';
            landing.style.pointerEvents = 'none';
            document.body.style.overflow = 'hidden'; // Kh√≥a cu·ªôn

            // Hi·ªán c√°c UI game
            document.querySelectorAll('.game-ui').forEach(el => el.classList.remove('game-ui'));
            // Hi·ªán Stats
            stats.dom.style.display = 'block';
            statsMem.dom.style.display = 'block';
            document.getElementById('gpu-info').style.display = 'block';
            
            // --- AUTO DETECT HARDWARE QUALITY (T·ª± ƒë·ªông ch·ªçn c·∫•u h√¨nh) ---
            // M·∫∑c ƒë·ªãnh Super Low theo y√™u c·∫ßu ƒë·ªÉ t·ªëi ∆∞u
            let autoLevel = 0;

            sysLog(`Hardware Detected: ${rendererInfo}`);
            sysLog(`Auto-Config: Level ${autoLevel} Selected`);
            window.setQuality(autoLevel);

            sysLog("Benchmark Mode: Engaged");
            
            // Arona ch√†o m·ª´ng khi v√†o GPU Mode (K√≠ch ho·∫°t √¢m thanh)
            setTimeout(() => window.triggerAiTalk("GPU Benchmark initiated. Good luck, Sensei!"), 800);
            
            setTimeout(() => {
                landing.style.display = 'none';
            }, 1000);
        };

        window.startCpuMode = function() {
            isGameActive = false; // ƒê·∫£m b·∫£o t·∫Øt render 3D
            
            const landing = document.getElementById('landing-screen');
            const cpuScreen = document.getElementById('cpu-screen');
            
            landing.style.opacity = 0;
            landing.style.transform = 'scale(5)';
            landing.style.pointerEvents = 'none';
            document.body.style.overflow = 'hidden'; // Kh√≥a cu·ªôn
            
            cpuScreen.style.display = 'flex';
            setTimeout(() => { cpuScreen.style.opacity = 1; }, 50);
            
            // T·∫°m d·ª´ng render 3D ƒë·ªÉ d·ªìn l·ª±c cho CPU
            // renderer.setAnimationLoop(null); // ƒê√£ ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi isGameActive

            // --- Detect System Info ---
            const ua = navigator.userAgent;
            let os = "Unknown OS";
            if (ua.indexOf("Win") !== -1) os = "Windows";
            if (ua.indexOf("Mac") !== -1) os = "MacOS";
            if (ua.indexOf("X11") !== -1) os = "UNIX";
            if (ua.indexOf("Linux") !== -1) os = "Linux";
            if (ua.indexOf("Android") !== -1) os = "Android";
            if (ua.indexOf("like Mac") !== -1) os = "iOS";

            let browser = "Unknown Browser";
            if (ua.indexOf("Firefox") > -1) browser = "Mozilla Firefox";
            else if (ua.indexOf("SamsungBrowser") > -1) browser = "Samsung Internet";
            else if (ua.indexOf("Opera") > -1 || ua.indexOf("OPR") > -1) browser = "Opera";
            else if (ua.indexOf("Edge") > -1) browser = "Microsoft Edge";
            else if (ua.indexOf("Chrome") > -1) browser = "Google Chrome";
            else if (ua.indexOf("Safari") > -1) browser = "Apple Safari";

            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
            const deviceType = isMobile ? "Mobile Device" : "Desktop/Laptop";

            document.getElementById('cpu-system-info').innerHTML = `SYSTEM: ${os} | BROWSER: ${browser}<br>TYPE: ${deviceType}`;
            
            setTimeout(() => {
                landing.style.display = 'none';
            }, 1000);

            const threads = navigator.hardwareConcurrency || 4;
            const statusEl = document.getElementById('cpu-status');
            const progressEl = document.getElementById('cpu-progress');
            const resultsEl = document.getElementById('cpu-results');
            const canvas = document.getElementById('cpu-render-canvas');
            const ctx = canvas.getContext('2d');

            // --- Pause/Resume Logic ---
            const pauseControls = document.getElementById('cpu-pause-controls');
            const pauseBtn = document.getElementById('cpu-pause-btn');
            const resumeBtn = document.getElementById('cpu-resume-btn');
            let isPaused = false;
            let originalStatusText = '';
            
            // --- Temp Monitor Logic ---
            const tempWrapper = document.getElementById('temp-chart-wrapper');
            const tempCanvas = document.getElementById('cpu-temp-chart');
            const tempCtx = tempCanvas.getContext('2d');
            const tempDisplay = document.getElementById('current-temp-display');
            
            let tempData = new Array(100).fill(35);
            let currentTemp = 35;
            let targetTemp = 35;
            let tempInterval;

            function drawTempGraph() {
                const w = tempCanvas.width;
                const h = tempCanvas.height;
                tempCtx.clearRect(0, 0, w, h);
                
                // Grid
                tempCtx.strokeStyle = 'rgba(255, 50, 50, 0.2)';
                tempCtx.lineWidth = 1;
                tempCtx.beginPath();
                for(let i=0; i<5; i++) {
                    let y = i * (h/4);
                    tempCtx.moveTo(0, y); tempCtx.lineTo(w, y);
                }
                tempCtx.stroke();

                // Graph
                tempCtx.strokeStyle = '#ff5555';
                tempCtx.lineWidth = 2;
                tempCtx.beginPath();
                for(let i=0; i<tempData.length; i++) {
                    const x = (i / (tempData.length - 1)) * w;
                    const y = h - ((tempData[i] - 30) / (100 - 30)) * h; // Scale 30-100C
                    if(i===0) tempCtx.moveTo(x, y); else tempCtx.lineTo(x, y);
                }
                tempCtx.stroke();
                
                // Fill
                tempCtx.lineTo(w, h);
                tempCtx.lineTo(0, h);
                tempCtx.fillStyle = 'rgba(255, 50, 50, 0.1)';
                tempCtx.fill();
            }

            function startTempMonitor() {
                tempWrapper.style.display = 'block';
                if(tempInterval) clearInterval(tempInterval);
                tempInterval = setInterval(() => {
                    // If paused, the target temp is forced to a cool state
                    const activeTarget = isPaused ? 38 : targetTemp;

                    // Physics for temp
                    if(currentTemp < activeTarget) currentTemp += (activeTarget - currentTemp) * 0.05;
                    else currentTemp -= (currentTemp - activeTarget) * 0.02;
                    
                    const jitter = (Math.random() - 0.5) * 1.0;
                    const val = Math.max(30, Math.min(100, currentTemp + jitter));
                    
                    tempData.push(val);
                    tempData.shift();
                    
                    tempDisplay.innerText = val.toFixed(1) + "¬∞C";
                    tempDisplay.style.color = val > 80 ? '#ff0000' : '#ff5555';
                    
                    drawTempGraph();
                }, 50);
            }
            
            startTempMonitor(); // Start immediately in idle mode

            // --- Raytracer Worker Code ---
            const workerBlob = new Blob([`
                self.onmessage = function(e) {
                    const { startY, endY, width, height, id, time, quality } = e.data;

                    // Gracefully handle empty/invalid chunks to prevent worker from hanging
                    if (startY >= endY) {
                        self.postMessage({ id, startY, endY, buffer: null });
                        return;
                    }

                    const data = new Uint8ClampedArray(width * (endY - startY) * 4);

                    // Define quality settings based on the passed value
                    const qualitySettings = {
                        draft:    { samples: 1, depth: 2 },
                        standard: { samples: 16, depth: 4 },
                        extreme:  { samples: 64, depth: 6 }
                    };
                    const currentQuality = qualitySettings[quality] || qualitySettings.standard;
                    const samples = currentQuality.samples;
                    const traceDepth = currentQuality.depth;

                    // Scene definition
                    const t = time * 0.001; // Gi·∫£m t·ªëc ƒë·ªô animation
                    const spheres = [
                        { c: {x: Math.sin(t)*2.5, y: -0.5, z: 4 + Math.cos(t)}, r: 0.5, col: {r: 255, g: 50, b: 50}, refl: 0.8 },
                        { c: {x: 1.2, y: -0.5 + Math.abs(Math.sin(t*2))*0.5, z: 3.5}, r: 0.5, col: {r: 50, g: 255, b: 50}, refl: 0.3 },
                        { c: {x: -1.2, y: -0.5, z: 3.5}, r: 0.5, col: {r: 50, g: 50, b: 255}, refl: 0.3 },
                        { c: {x: 0, y: -100.5, z: 3}, r: 100, col: {r: 150, g: 150, b: 200}, refl: 0.1 }, // Floor
                        { c: {x: Math.cos(t*1.5)*2.0, y: 0.2, z: 3 + Math.sin(t*1.5)*2.0}, r: 0.3, col: {r: 255, g: 255, b: 50}, refl: 0.1 },
                        { c: {x: 0, y: 0.5, z: 2.5}, r: 0.2, col: {r: 255, g: 50, b: 255}, refl: 0.95 } // Glassy sphere
                    ];
                    const light = { x: 5*Math.cos(t*0.5), y: 5, z: 5*Math.sin(t*0.5) }; // ƒê√®n di chuy·ªÉn

                    function dot(v1, v2) { return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z; }
                    function sub(v1, v2) { return {x: v1.x-v2.x, y: v1.y-v2.y, z: v1.z-v2.z}; }
                    function add(v1, v2) { return {x: v1.x+v2.x, y: v1.y+v2.y, z: v1.z+v2.z}; }
                    function mul(v, s) { return {x: v.x*s, y: v.y*s, z: v.z*s}; }
                    function normalize(v) { const len = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z); return {x: v.x/len, y: v.y/len, z: v.z/len}; }

                    function intersect(ro, rd) {
                        let t = Infinity;
                        let obj = null;
                        for(let s of spheres) {
                            const oc = sub(ro, s.c);
                            const b = dot(oc, rd);
                            const c = dot(oc, oc) - s.r*s.r;
                            const d = b*b - c;
                            if(d > 0) {
                                const temp = -b - Math.sqrt(d);
                                if(temp > 0.001 && temp < t) { t = temp; obj = s; }
                            }
                        }
                        return {t, obj};
                    }

                    function trace(ro, rd, depth) {
                        let col = {r: 0, g: 0, b: 0};
                        const hit = intersect(ro, rd);
                        if(hit.obj) {
                            const p = add(ro, mul(rd, hit.t));
                            const n = normalize(sub(p, hit.obj.c));
                            const l = normalize(sub(light, p));
                            const diff = Math.max(0, dot(n, l));

                            // Shadow
                            const shadowHit = intersect(add(p, mul(n, 0.001)), l);
                            const shadow = (shadowHit.obj) ? 0.3 : 1.0; // B√≥ng t·ªëi h∆°n

                            col.r = hit.obj.col.r * diff * shadow;
                            col.g = hit.obj.col.g * diff * shadow;
                            col.b = hit.obj.col.b * diff * shadow;

                            if(depth > 0 && hit.obj.refl > 0) {
                                const reflDir = sub(rd, mul(n, 2 * dot(rd, n)));
                                const reflCol = trace(add(p, mul(n, 0.001)), normalize(reflDir), depth - 1);
                                col.r = col.r * (1-hit.obj.refl) + reflCol.r * hit.obj.refl;
                                col.g = col.g * (1-hit.obj.refl) + reflCol.g * hit.obj.refl;
                                col.b = col.b * (1-hit.obj.refl) + reflCol.b * hit.obj.refl;
                            }
                        } else {
                            // Sky gradient
                            const t = 0.5 * (rd.y + 1.0);
                            col.r = (1-t)*255 + t*100;
                            col.g = (1-t)*255 + t*150;
                            col.b = (1-t)*255 + t*255;
                        }
                        return col;
                    }

                    let idx = 0;
                    for(let y = startY; y < endY; y++) {
                        for(let x = 0; x < width; x++) {
                            let totalCol = {r: 0, g: 0, b: 0};
                            for (let s = 0; s < samples; s++) {
                                // Camera setup v·ªõi jitter ng·∫´u nhi√™n ƒë·ªÉ kh·ª≠ rƒÉng c∆∞a
                                const uv = {
                                    x: ((x + Math.random()) / width) * 2 - 1,
                                    y: -((y + Math.random()) / height) * 2 + 1
                                };
                                uv.x *= width / height;
                                const ro = {x: 0, y: 0, z: 0};
                                const rd = normalize({x: uv.x, y: uv.y, z: 1});

                                const col = trace(ro, rd, traceDepth); // Use dynamic depth
                                totalCol.r += col.r;
                                totalCol.g += col.g;
                                totalCol.b += col.b;
                            }

                            data[idx++] = totalCol.r / samples;
                            data[idx++] = totalCol.g / samples;
                            data[idx++] = totalCol.b / samples;
                            data[idx++] = 255;
                        }
                    }
                    self.postMessage({ id, startY, endY, buffer: data.buffer }, [data.buffer]);_
                };
            `], { type: 'text/javascript' });
            const workerUrl = URL.createObjectURL(workerBlob);

            // --- Pause/Resume Implementation ---
            function awaitPause() {
                return new Promise(resolve => {
                    const check = () => {
                        if (!isPaused) {
                            resolve();
                        } else {
                            // Use rAF to wait without blocking the main thread
                            requestAnimationFrame(check);
                        }
                    };
                    check();
                });
            }

            pauseBtn.onclick = function() {
                // Can only pause if benchmark is running
                if (isPaused || !document.getElementById('cpu-start-btn').disabled) return;
                
                isPaused = true;
                originalStatusText = statusEl.innerText;
                statusEl.innerText = "BENCHMARK PAUSED";
                statusEl.style.color = "#ffaa00";

                pauseBtn.style.display = 'none';
                resumeBtn.style.display = 'block';
            };

            resumeBtn.onclick = function() {
                if (!isPaused) return;
                isPaused = false;
                statusEl.innerText = originalStatusText;
                statusEl.style.color = "#00ffff"; // Restore running color

                // Restore target temperature based on current stage
                if (completedFrames < frameCount) {
                    targetTemp = 65 + Math.random() * 10;
                } else {
                    targetTemp = 85 + Math.random() * 10;
                }

                pauseBtn.style.display = 'block';
                resumeBtn.style.display = 'none';
            };

            const chunkCount = 32; 

            function runRenderTask(concurrency, time, quality, onChunkComplete) {
                const width = canvas.width;
                const height = canvas.height;
                // Chia nh·ªè h√¨nh ·∫£nh th√†nh nhi·ªÅu ph·∫ßn ƒë·ªÉ hi·ªÉn th·ªã ti·∫øn tr√¨nh (Scanline effect)
                const chunkHeight = Math.ceil(height / chunkCount);
                
                // KH√îNG clearRect ƒë·ªÉ gi·ªØ l·∫°i h√¨nh ·∫£nh c≈© trong khi render ƒë√® l√™n

                return new Promise(resolve => {
                    const startTime = performance.now();
                    const queue = [];
                    
                    // T·∫°o h√†ng ƒë·ª£i c√°c chunk c·∫ßn render
                    for(let i=0; i<chunkCount; i++) {
                        queue.push({
                            startY: i * chunkHeight,
                            endY: Math.min((i + 1) * chunkHeight, height),
                            id: i
                        });
                    }
                    
                    const numWorkers = Math.min(concurrency, chunkCount);
                    let finishedCount = 0;

                    function startWorker() {
                        const worker = new Worker(workerUrl);
                        
                        function processNext() {
                            if (queue.length === 0) {
                                worker.terminate();
                                finishedCount++;
                                if (finishedCount === numWorkers) {
                                    resolve(performance.now() - startTime);
                                }
                                return;
                            }
                            
                            const task = queue.shift();
                            worker.postMessage({ 
                                startY: task.startY, 
                                endY: task.endY, 
                                width, 
                                height, 
                                id: task.id, 
                                time,
                                quality
                            });
                        }
                        
                        worker.onmessage = function(e) {
                            const { startY, endY, buffer } = e.data;
                            // Only draw if the buffer is not null (i.e., it was a valid chunk)
                            if (buffer) {
                                const imgData = new ImageData(new Uint8ClampedArray(buffer), width, endY - startY);
                                ctx.putImageData(imgData, 0, startY);
                            }
                            if (onChunkComplete) onChunkComplete();
                            processNext();
                        };
                        
                        processNext();
                    }
                    
                    for(let i=0; i<numWorkers; i++) {
                        startWorker();
                    }
                });
            }

            async function runBenchmark() {
                document.getElementById('cpu-start-btn').disabled = true;
                document.getElementById('cpu-res-select').disabled = true;
                document.getElementById('cpu-quality-select').disabled = true;
                document.getElementById('cpu-start-btn').innerText = "RUNNING...";
                document.getElementById('cpu-chart-canvas').style.display = 'none'; // Hide old chart if re-running
                
                // Show and reset pause controls
                pauseControls.style.display = 'flex';
                pauseBtn.style.display = 'block';
                resumeBtn.style.display = 'none';
                isPaused = false;
                
                const frameCount = 60; // Render 60 frames ƒë·ªÉ k√©o d√†i th·ªùi gian test
                const totalFrames = frameCount * 2; // Single-core + Multi-core
                let completedFrames = 0;
                let completedChunksInFrame = 0;

                const quality = document.getElementById('cpu-quality-select').value;

                const width = canvas.width;
                const height = canvas.height;
                const totalPixels = width * height;

                const onChunkComplete = () => {
                    completedChunksInFrame++;
                    const frameProgress = completedChunksInFrame / chunkCount;
                    const overallProgress = ((completedFrames + frameProgress) / totalFrames) * 100;
                    progressEl.style.width = `${overallProgress}%`;
                };

                // 1. Single Core Test
                targetTemp = 65 + Math.random() * 10; // Heat up
                let totalTimeSingle = 0;
                for(let i=0; i<frameCount; i++) {
                    await awaitPause(); // Check for pause
                    statusEl.innerText = `SINGLE-CORE: ANALYZING FRAME ${i+1}/${frameCount}`;
                    completedChunksInFrame = 0; // Reset counter for the new frame
                    const t = await runRenderTask(1, i * 50, quality, onChunkComplete);
                    totalTimeSingle += t;
                    completedFrames++;
                }
                const avgTimeSingle = totalTimeSingle / frameCount;
                // Score = Pixels per Second / 100
                const scoreSingle = Math.floor((totalPixels / avgTimeSingle) * 1000 / 100);
                
                // C·∫≠p nh·∫≠t ƒëi·ªÉm ƒë∆°n nh√¢n v√† tr·∫°ng th√°i ngay khi ho√†n th√†nh
                document.querySelector('#score-single .val').innerText = scoreSingle.toLocaleString();
                document.querySelector('#score-single .val').style.color = '#00ff00';
                resultsEl.innerHTML = `Single-Core Score: ${scoreSingle.toLocaleString()}<br>Avg Frame Time: ${avgTimeSingle.toFixed(1)}ms<br><br><span style="color:#888;">...ANALYZING MULTI-CORE PERFORMANCE...</span>`;

                await new Promise(r => setTimeout(r, 1000)); // Pause

                // 2. Multi Core Test
                targetTemp = 85 + Math.random() * 10; // Heat up more
                let totalTimeMulti = 0;
                for(let i=0; i<frameCount; i++) {
                    await awaitPause(); // Check for pause
                    statusEl.innerText = `MULTI-CORE (${threads} THREADS): ANALYZING FRAME ${i+1}/${frameCount}`;
                    completedChunksInFrame = 0; // Reset counter for the new frame
                    const t = await runRenderTask(threads, i * 50, quality, onChunkComplete);
                    totalTimeMulti += t;
                    completedFrames++;
                }
                const avgTimeMulti = totalTimeMulti / frameCount;
                const scoreMulti = Math.floor((totalPixels / avgTimeMulti) * 1000 / 100);
                
                document.querySelector('#score-multi .val').innerText = scoreMulti.toLocaleString();
                document.querySelector('#score-multi .val').style.color = '#00ff00';

                targetTemp = 40; // Cool down
                // Finish
                statusEl.innerText = "BENCHMARK COMPLETE";
                statusEl.style.color = "#00ff00";
                document.querySelector('.cyber-progress-bar').style.background = "repeating-linear-gradient(45deg, #00ff00, #00ff00 10px, #008800 10px, #008800 20px)";
                document.querySelector('.cyber-progress-container').style.borderColor = "#00ff00";

                // Real World Leaderboard Data (Estimated JS Raytracing Scores)
                const leaderboardData = [
                    { name: "Desktop (Core i9-14900K)", score: 28500 },
                    { name: "MacBook Pro (M3 Max)", score: 26000 },
                    { name: "Desktop (Ryzen 9 7950X)", score: 25500 },
                    { name: "iPhone 15 Pro (A17 Pro)", score: 18500 },
                    { name: "Gaming Laptop (i7-13700H)", score: 16000 },
                    { name: "Android Flagship (SD 8 Gen 3)", score: 14500 },
                    { name: "MacBook Air (M2)", score: 11000 },
                    { name: "Mid-Range PC (i5-12400)", score: 9500 },
                    { name: "Budget Laptop (Ryzen 5)", score: 6500 },
                    { name: "Budget Phone (Snapdragon 695)", score: 2500 },
                    { name: "Old Laptop (Celeron)", score: 800 }
                ];
                
                leaderboardData.push({ name: "YOUR DEVICE", score: scoreMulti, isUser: true });
                leaderboardData.sort((a, b) => b.score - a.score);
                
                let lbHtml = `
                    <div class="leaderboard">
                        <div class="leaderboard-header">
                            <div class="leaderboard-rank">#</div>
                            <div class="leaderboard-name">DEVICE</div>
                            <div class="leaderboard-score">SCORE</div>
                        </div>
                `;
                
                leaderboardData.forEach((item, index) => {
                    const rank = index + 1;
                    const userClass = item.isUser ? 'user' : '';
                    lbHtml += `
                        <div class="leaderboard-item ${userClass}">
                            <div class="leaderboard-rank">${rank}</div>
                            <div class="leaderboard-name">${item.name}</div>
                            <div class="leaderboard-score">${item.score.toLocaleString()}</div>
                        </div>
                    `;
                });
                lbHtml += '</div>';

                resultsEl.innerHTML = `
                    Single-Core Score: ${scoreSingle.toLocaleString()}<br>
                    Multi-Core Score: ${scoreMulti.toLocaleString()}<br>
                    Avg Frame Time: ${avgTimeSingle.toFixed(1)}ms (Single) / ${avgTimeMulti.toFixed(1)}ms (Multi)<br>
                    Threads Used: ${threads}
                    ${lbHtml}
                `;

                // --- Draw Comparison Chart (V·∫Ω bi·ªÉu ƒë·ªì so s√°nh) ---
                const chartCanvas = document.getElementById('cpu-chart-canvas');
                chartCanvas.style.display = 'block';
                const ctxChart = chartCanvas.getContext('2d');
                const cw = chartCanvas.width;
                const ch = chartCanvas.height;
                
                ctxChart.clearRect(0, 0, cw, ch);
                
                // Ti√™u ƒë·ªÅ bi·ªÉu ƒë·ªì
                ctxChart.fillStyle = '#fff';
                ctxChart.font = 'bold 16px monospace';
                ctxChart.textAlign = 'center';
                ctxChart.fillText('PERFORMANCE COMPARISON', cw/2, 30);
                
                const maxScore = leaderboardData[0].score;
                
                leaderboardData.forEach((item, i) => {
                    const y = 60 + i * 28;
                    if(y > ch - 20) return;

                    // T√™n thi·∫øt b·ªã
                    ctxChart.font = '12px monospace';
                    ctxChart.textAlign = 'right';
                    ctxChart.fillStyle = item.isUser ? '#00ff00' : '#888';
                    ctxChart.fillText(item.name, 200, y + 10);

                    // Thanh ƒëi·ªÉm s·ªë
                    const barWidth = (item.score / maxScore) * (cw - 280);
                    ctxChart.fillStyle = item.isUser ? '#00ff00' : '#333';
                    ctxChart.fillRect(210, y - 5, barWidth, 18);

                    // S·ªë ƒëi·ªÉm
                    ctxChart.textAlign = 'left';
                    ctxChart.fillStyle = '#fff';
                    ctxChart.fillText(item.score.toLocaleString(), 210 + barWidth + 8, y + 10);
                });

                document.getElementById('cpu-start-btn').disabled = false;
                document.getElementById('cpu-res-select').disabled = false;
                document.getElementById('cpu-quality-select').disabled = false;
                document.getElementById('cpu-start-btn').innerText = "RE-RUN TEST";

                // Hide pause controls on finish
                pauseControls.style.display = 'none';
            }

            const startBtn = document.getElementById('cpu-start-btn');
            startBtn.onclick = function() {
                const res = document.getElementById('cpu-res-select').value.split('x');
                canvas.width = parseInt(res[0]);
                canvas.height = parseInt(res[1]);
                runBenchmark();
            };
        };

        // --- T√çNH NƒÇNG M·ªöI: Auto Director (ƒê·∫°o di·ªÖn t·ª± ƒë·ªông) ---
        let isDirectorMode = false;
        const directorBtn = document.getElementById('director-btn');
        let shotStartTime = 0;
        let shotDuration = 0;
        const camStartPos = new THREE.Vector3();
        const camEndPos = new THREE.Vector3();
        const camLookStart = new THREE.Vector3();
        const camLookEnd = new THREE.Vector3();

        function toggleDirector() {
            isDirectorMode = !isDirectorMode;
            controls.enabled = !isDirectorMode; // T·∫Øt ƒëi·ªÅu khi·ªÉn tay khi b·∫≠t Auto
            
            const barTop = document.getElementById('cinematic-bar-top');
            const barBottom = document.getElementById('cinematic-bar-bottom');
            
            if (isDirectorMode) {
                directorBtn.classList.add('active');
                directorBtn.innerText = "DIRECTOR: ON";
                // B·∫≠t Cinematic Bars (12% chi·ªÅu cao m·ªói d·∫£i)
                barTop.style.height = "12%";
                barBottom.style.height = "12%";
                pickNewShot();
            } else {
                directorBtn.classList.remove('active');
                directorBtn.innerText = "AUTO DIRECTOR";
                // T·∫Øt Cinematic Bars
                barTop.style.height = "0";
                barBottom.style.height = "0";
                controls.target.set(0, 0, 0); // Reset target v·ªÅ t√¢m
            }
            sysLog(`Auto Director: ${isDirectorMode ? 'ON' : 'OFF'}`);
        }

        directorBtn.addEventListener('click', toggleDirector);

        function pickNewShot() {
            shotStartTime = Date.now() * 0.001;
            shotDuration = 4 + Math.random() * 6; // 4-10 gi√¢y m·ªói c·∫£nh

            // Random v·ªã tr√≠ camera
            const r = Math.random();
            
            // Target ng·∫´u nhi√™n quanh t√¢m
            camLookStart.set((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
            camLookEnd.copy(camLookStart).addScalar((Math.random()-0.5)*5);

            if (r < 0.25) { // C·∫≠n c·∫£nh (Close-up)
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 10;
                camStartPos.set(Math.cos(angle)*radius, (Math.random()-0.5)*5, Math.sin(angle)*radius);
                camEndPos.copy(camStartPos).add(new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2));
            } else if (r < 0.5) { // To√†n c·∫£nh (Wide shot) xoay nh·∫π
                const angle = Math.random() * Math.PI * 2;
                const radius = 60 + Math.random() * 30;
                const y = (Math.random()-0.5) * 40;
                camStartPos.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
                const angle2 = angle + 0.5; // Xoay m·ªôt ƒëo·∫°n
                camEndPos.set(Math.cos(angle2)*radius, y, Math.sin(angle2)*radius);
            } else if (r < 0.75) { // G√≥c th·∫•p/cao (Low/High angle)
                const angle = Math.random() * Math.PI * 2;
                const radius = 40 + Math.random() * 20;
                camStartPos.set(Math.cos(angle)*radius, (Math.random() > 0.5 ? 40 : -40), Math.sin(angle)*radius);
                camEndPos.set(Math.cos(angle)*radius*0.8, 0, Math.sin(angle)*radius*0.8); // Zoom v√†o
            } else { // Bay xuy√™n qua (Fly-through)
                camStartPos.set((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
                camEndPos.set((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
            }
        }

        function updateDirector() {
            const now = Date.now() * 0.001;
            const elapsed = now - shotStartTime;
            if (elapsed > shotDuration) { pickNewShot(); return; }
            const progress = elapsed / shotDuration;
            const smooth = progress * progress * (3 - 2 * progress); // Smoothstep
            camera.position.lerpVectors(camStartPos, camEndPos, smooth);
            const currentLook = new THREE.Vector3().lerpVectors(camLookStart, camLookEnd, smooth);
            camera.lookAt(currentLook);
        }

        // --- T√çNH NƒÇNG M·ªöI: Benchmark Mode (Ch·∫•m ƒëi·ªÉm hi·ªáu nƒÉng) ---
        let isBenchmarking = false;
        let benchStartTime = 0;
        let benchFrames = 0;
        let benchFrameTimes = [];
        const benchmarkBtn = document.getElementById('benchmark-btn');

        benchmarkBtn.addEventListener('click', () => {
            if(isBenchmarking) return;
            isBenchmarking = true;
            benchFrames = 0;
            benchFrameTimes = [];
            benchStartTime = performance.now();
            
            // T·ª± ƒë·ªông b·∫≠t ch·∫ø ƒë·ªô Director ƒë·ªÉ camera di chuy·ªÉn
            if(!isDirectorMode) toggleDirector();
            
            // ·∫®n UI
            document.querySelector('.quality-controls').style.display = 'none';
            benchmarkBtn.innerText = "BENCHMARKING...";
            benchmarkBtn.style.color = "#ff0000";
            benchmarkBtn.style.borderColor = "#ff0000";
            sysLog("Starting Performance Analysis...");
        });

        function finishBenchmark(durationMs) {
            isBenchmarking = false;
            const avgFps = benchFrames / (durationMs / 1000);
            
            // T√≠nh 1% Low FPS
            // Chuy·ªÉn ƒë·ªïi frame time th√†nh FPS v√† s·∫Øp x·∫øp tƒÉng d·∫ßn
            const fpsValues = benchFrameTimes.map(t => t > 0 ? 1/t : 0).sort((a, b) => a - b);
            const index1Low = Math.floor(fpsValues.length * 0.01);
            const low1Percent = fpsValues[index1Low] || 0;

            // C√¥ng th·ª©c t√≠nh ƒëi·ªÉm: FPS * (Level^1.5) * 100
            // Level c√†ng cao ƒëi·ªÉm c√†ng ƒë∆∞·ª£c nh√¢n nhi·ªÅu
            const levelMultiplier = Math.pow((window.currentQualityLevel || 1) + 1, 1.5); 
            const score = Math.floor(avgFps * levelMultiplier * 50);

            // Hi·ªÉn th·ªã k·∫øt qu·∫£
            document.getElementById('benchmark-score').innerText = score;
            document.getElementById('benchmark-fps').innerHTML = `AVG FPS: ${avgFps.toFixed(1)} <span style="color:#ff0055; margin-left:10px;">1% LOW: ${low1Percent.toFixed(1)}</span> | Quality: LV${window.currentQualityLevel}`;
            document.getElementById('benchmark-modal').style.display = 'block';

            // Kh√¥i ph·ª•c UI
            document.querySelector('.quality-controls').style.display = 'flex';
            benchmarkBtn.innerText = "RUN BENCHMARK";
            benchmarkBtn.style.color = "#00ffff";
            benchmarkBtn.style.borderColor = "#00ffff";

            // T·∫Øt Director mode
            if(isDirectorMode) toggleDirector();
            sysLog(`Benchmark Done. Score: ${score}`);
        }

        // --- T√çNH NƒÇNG M·ªöI: H·ªá th·ªëng ƒëi·ªÅu ch·ªânh ch·∫•t l∆∞·ª£ng ƒë·ªì h·ªça (5 C·∫•p ƒë·ªô) ---
        window.currentQualityLevel = 1; // M·∫∑c ƒë·ªãnh

        window.setQuality = function(level) {
            // --- HYPERSPACE JUMP SEQUENCE ---
            sysLog("INITIATING HYPERSPACE JUMP...");
            isWarping = true; 
            if(warpBtn) warpBtn.classList.add('active');

            const overlay = document.getElementById('transition-overlay');
            
            // 1. ƒê·ª£i Warp tƒÉng t·ªëc (800ms) r·ªìi m·ªõi Fade Out
            setTimeout(() => {
                overlay.style.opacity = 1;

                // 2. ƒê·ª£i m√†n h√¨nh ƒëen r·ªìi m·ªõi ƒë·ªïi c·∫•u h√¨nh (500ms)
                setTimeout(() => {
                    window.currentQualityLevel = level;

                // C·∫≠p nh·∫≠t UI
                document.querySelectorAll('.quality-btn').forEach((btn, idx) => {
                    // idx 0 l√† Super Low (level 0), idx 1 l√† Low (level 1)...
                    if (idx === level) btn.classList.add('active');
                    else btn.classList.remove('active');
                });

                // C·∫•u h√¨nh cho t·ª´ng c·∫•p ƒë·ªô
                const config = {
                    0: { debris: 200,  vortex: 100,  swarm: 200,   particles: 2000,  shadow: 0,    torus: [60, 8],     titan: [60, 8],     passes: [false, false, false, false, false] }, // Super Low
                    1: { debris: 2000, vortex: 1000, swarm: 2000, particles: 10000, shadow: 512,  torus: [300, 32],   titan: [200, 32],   passes: [false, false, false, false, false] }, // Low
                    2: { debris: 5000, vortex: 3000, swarm: 5000, particles: 20000, shadow: 1024, torus: [500, 64],   titan: [500, 64],   passes: [true, false, false, false, false] },  // Medium
                    3: { debris: 8000, vortex: 5000, swarm: 10000, particles: 40000, shadow: 2048, torus: [800, 100],  titan: [1000, 100], passes: [true, true, false, false, true] },   // High (+SSAO, +Dirt)
                    4: { debris: 10000, vortex: 7000, swarm: 15000, particles: 50000, shadow: 4096, torus: [1200, 150], titan: [2000, 200], passes: [true, true, true, false, true] },    // Ultra (+GodRays)
                    5: { debris: 12000, vortex: 8000, swarm: 20000, particles: 60000, shadow: 4096, torus: [1500, 200], titan: [2500, 400], passes: [true, true, true, true, true] }      // Extreme (+Sharpen)
                }[level];

                // 1. C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng v·∫≠t th·ªÉ (InstancedMesh & Particles)
                debrisMesh.count = config.debris;
                vortexMesh.count = config.vortex;
                swarmMesh.count = config.swarm;
                particlesMesh.geometry.setDrawRange(0, config.particles);

                // 2. C·∫≠p nh·∫≠t Post-processing [Bokeh, SSAO, GodRays, Sharpen, LensDirt]
                bokehPass.enabled = config.passes[0];
                ssaoPass.enabled = config.passes[1];
                godRaysPass.enabled = config.passes[2];
                sharpenPass.enabled = config.passes[3];
                lensDirtPass.enabled = config.passes[4];

                // 3. C·∫≠p nh·∫≠t Geometry (V·∫≠t th·ªÉ ch√≠nh & Titan) - N·∫∑ng nh·∫•t
                // Dispose c≈©
                torusKnot.geometry.dispose();
                titanMesh.geometry.dispose();
                
                // T·∫°o m·ªõi v·ªõi ƒë·ªô ph√¢n gi·∫£i t∆∞∆°ng ·ª©ng
                const newTorusGeo = new THREE.TorusKnotGeometry(10, 3, config.torus[0], config.torus[1]);
                torusKnot.geometry = newTorusGeo;
                wireframeMesh.geometry = newTorusGeo; // C·∫≠p nh·∫≠t c·∫£ l·ªõp v·ªè wireframe

                const newTitanGeo = new THREE.TorusKnotGeometry(60, 2, config.titan[0], config.titan[1], 2, 5);
                titanMesh.geometry = newTitanGeo;

                // 4. C·∫≠p nh·∫≠t Shadow Map Resolution
                const lights = [pointLight1, pointLight2, pointLight3];
                lights.forEach(light => {
                    if (config.shadow === 0) {
                        light.castShadow = false; // T·∫Øt b√≥ng ƒë·ªï ·ªü ch·∫ø ƒë·ªô Super Low
                    } else {
                        light.castShadow = true;
                        light.shadow.mapSize.width = config.shadow;
                        light.shadow.mapSize.height = config.shadow;
                    }
                    
                    // Bu·ªôc renderer c·∫≠p nh·∫≠t shadow map (dispose map c≈©)
                    if (light.shadow.map) {
                        light.shadow.map.dispose();
                        light.shadow.map = null;
                    }
                });

                // 5. T·ªëi ∆∞u Pixel Ratio cho Super Low
                if (level === 0) renderer.setPixelRatio(0.75); // Gi·∫£m ƒë·ªô ph√¢n gi·∫£i render ƒë·ªÉ m∆∞·ª£t h∆°n
                else renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setSize(window.innerWidth, window.innerHeight); // C·∫≠p nh·∫≠t l·∫°i k√≠ch th∆∞·ªõc

                console.log(`ƒê√£ chuy·ªÉn sang C·∫•p ƒë·ªô ${level}`);
                sysLog(`Graphics Quality: Level ${level}`);
                
                // 3. Fade In (Hi·ªán l·∫°i c·∫£nh)
                overlay.style.opacity = 0;

                // 4. T·∫Øt Warp sau khi ƒë√£ hi·ªán c·∫£nh (t·∫°o c·∫£m gi√°c gi·∫£m t·ªëc khi ƒë·∫øn n∆°i)
                setTimeout(() => {
                    isWarping = false;
                    if(warpBtn) warpBtn.classList.remove('active');
                    sysLog("HYPERSPACE JUMP COMPLETE");
                }, 800);

                }, 500);
            }, 800);
        };

        // --- T√çNH NƒÇNG M·ªöI: Screenshot (Ph√≠m P) ---
        function takeScreenshot() {
            const link = document.createElement('a');
            link.download = `quantum_benchmark_${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
            sysLog("Screenshot Saved");
        }
        document.getElementById('screenshot-btn').addEventListener('click', takeScreenshot);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') takeScreenshot();
        });

        // --- T√çNH NƒÇNG M·ªöI: Landing Page Interactive Tilt ---
        const cardsContainer = document.getElementById('cards-container');
        const landingScreen = document.getElementById('landing-screen');
        
        landingScreen.addEventListener('mousemove', (e) => {
            if(landingScreen.style.display === 'none') return;
            
            const x = (e.clientX / window.innerWidth - 0.5) * 2; // -1 to 1
            const y = (e.clientY / window.innerHeight - 0.5) * 2; // -1 to 1
            
            // Xoay nh·∫π container ng∆∞·ª£c chi·ªÅu chu·ªôt
            cardsContainer.style.transform = `rotateY(${x * 5}deg) rotateX(${-y * 5}deg)`;
        });

        // --- T√çNH NƒÇNG M·ªöI: UI Sound Effects (Hover) ---
        const uiAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playHoverSound() {
            // Th·ª≠ resume context n·∫øu ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t (Browser Policy)
            if (uiAudioCtx.state === 'suspended') uiAudioCtx.resume().catch(() => {});
            
            const osc = uiAudioCtx.createOscillator();
            const gain = uiAudioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(uiAudioCtx.destination);
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, uiAudioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1000, uiAudioCtx.currentTime + 0.1);
            
            gain.gain.setValueAtTime(0.05, uiAudioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, uiAudioCtx.currentTime + 0.1);
            
            osc.start();
            osc.stop(uiAudioCtx.currentTime + 0.1);
        }

        document.querySelectorAll('.choice-card').forEach(card => {
            card.addEventListener('mouseenter', playHoverSound);
        });

        // --- T√çNH NƒÇNG M·ªöI: Landing Page Particles ---
        function createLandingParticles() {
            const container = document.getElementById('landing-screen');
            for(let i=0; i<30; i++) {
                const p = document.createElement('div');
                p.classList.add('landing-particle');
                p.style.left = Math.random() * 100 + '%';
                p.style.top = (Math.random() * 100 + 100) + '%'; // Start below
                p.style.width = p.style.height = (Math.random() * 3 + 1) + 'px';
                p.style.animationDuration = (Math.random() * 5 + 5) + 's';
                p.style.animationDelay = (Math.random() * 5) + 's';
                container.appendChild(p);
            }
        }
        createLandingParticles();

        // --- T√çNH NƒÇNG M·ªöI: Shooting Stars ---
        function createShootingStar() {
            const container = document.getElementById('landing-screen');
            if(container.style.display === 'none') return;

            const star = document.createElement('div');
            star.classList.add('shooting-star');
            
            // Random start position
            const startX = Math.random() * window.innerWidth;
            const startY = Math.random() * window.innerHeight * 0.7; // Top 70%
            
            star.style.left = startX + 'px';
            star.style.top = startY + 'px';
            
            // Random angle (falling down-right or down-left)
            const angle = Math.random() > 0.5 ? (30 + Math.random() * 20) : (130 + Math.random() * 20);
            star.style.setProperty('--angle', angle + 'deg');
            
            // Random duration
            const duration = 2 + Math.random() * 2;
            star.style.animationDuration = duration + 's';

            container.appendChild(star);
            
            // Cleanup
            setTimeout(() => {
                star.remove();
            }, duration * 1000);
        }
        setInterval(createShootingStar, 1500);

        // --- T√çNH NƒÇNG M·ªöI: UI Sound Effects (Hover) ---
        // ƒê√£ c√≥ uiAudioCtx ·ªü tr√™n, t√°i s·ª≠ d·ª•ng ho·∫∑c t·∫°o m·ªõi n·∫øu c·∫ßn
        // H√†m n√†y ƒë·∫£m b·∫£o an to√†n khi AudioContext ch∆∞a ƒë∆∞·ª£c ph√©p ch·∫°y
        function playHoverSoundSafe() {
            if (!uiAudioCtx) return;
            if (uiAudioCtx.state === 'suspended') uiAudioCtx.resume().catch(() => {});
            
            const osc = uiAudioCtx.createOscillator();
            const gain = uiAudioCtx.createGain();
            osc.connect(gain);
            gain.connect(uiAudioCtx.destination);
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, uiAudioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1200, uiAudioCtx.currentTime + 0.05);
            
            gain.gain.setValueAtTime(0.03, uiAudioCtx.currentTime); // √Çm l∆∞·ª£ng nh·ªè v·ª´a ph·∫£i
            gain.gain.exponentialRampToValueAtTime(0.001, uiAudioCtx.currentTime + 0.05);
            
            osc.start();
            osc.stop(uiAudioCtx.currentTime + 0.05);
        }
        document.querySelectorAll('.choice-card').forEach(card => {
            card.addEventListener('mouseenter', playHoverSoundSafe);
        });

        // --- T√çNH NƒÇNG M·ªöI: Card Spotlight & Hacker Text ---
        document.querySelectorAll('.choice-card').forEach(card => {
            // 1. Spotlight Effect (√Ånh s√°ng theo chu·ªôt)
            card.addEventListener('mousemove', (e) => {
                const rect = card.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                card.style.setProperty('--mouse-x', `${x}px`);
                card.style.setProperty('--mouse-y', `${y}px`);
            });

            // 2. Hacker Text Effect (Hi·ªáu ·ª©ng gi·∫£i m√£ ch·ªØ tr√™n th·∫ª <p>)
            const desc = card.querySelector('p');
            if(desc) {
                const originalText = desc.innerText;
                const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*";
                
                card.addEventListener('mouseenter', () => {
                    let iterations = 0;
                    const interval = setInterval(() => {
                        desc.innerText = originalText.split("").map((letter, index) => {
                            if(index < iterations) return originalText[index];
                            return chars[Math.floor(Math.random() * chars.length)];
                        }).join("");
                        
                        if(iterations >= originalText.length) clearInterval(interval);
                        iterations += 1 / 2; // T·ªëc ƒë·ªô gi·∫£i m√£
                    }, 30);
                });
            }
        });

        // --- T√çNH NƒÇNG M·ªöI: Ripple Effect on Click ---
        function createRipple(event) {
            const card = event.currentTarget;
            const circle = document.createElement("span");
            const diameter = Math.max(card.clientWidth, card.clientHeight);
            const radius = diameter / 2;
            circle.style.width = circle.style.height = `${diameter}px`;
            circle.style.left = `${event.clientX - card.getBoundingClientRect().left - radius}px`;
            circle.style.top = `${event.clientY - card.getBoundingClientRect().top - radius}px`;
            circle.classList.add("ripple");
            const ripple = card.getElementsByClassName("ripple")[0];
            if (ripple) ripple.remove();
            card.appendChild(circle);
            setTimeout(() => circle.remove(), 600);
        }
        document.querySelectorAll('.choice-card').forEach(card => {
            card.addEventListener('click', createRipple);
        });

        // --- T√çNH NƒÇNG M·ªöI: Typewriter Effect ---
        const typeTextStr = "SYSTEM VERSION 2.0.4 | READY";
        const typeElement = document.getElementById('typewriter-text');
        let typeIndex = 0;

        function typeWriterEffect() {
            if (typeIndex < typeTextStr.length) {
                typeElement.textContent += typeTextStr.charAt(typeIndex);
                typeIndex++;
                setTimeout(typeWriterEffect, 50 + Math.random() * 30);
            } else {
                typeElement.style.animation = "blinkCursor 1s step-end infinite";
            }
        }
        setTimeout(typeWriterEffect, 500);

        // --- T√çNH NƒÇNG M·ªöI: AI Assistant Logic ---
        const aiBubble = document.getElementById('ai-bubble');
        let aiTimeout;
        
        // --- T√çNH NƒÇNG M·ªöI: AI Settings Object ---
        const aiSettings = {
            avatar: 'arona',
            halo: true,
            volume: 0.8,
            showCharacterHalo: true,
            haloColor: '#00ffff'
        };

        // --- C·∫§U H√åNH GI·ªåNG N√ìI ARONA ---
        const aiVoiceMap = {
            "arona": {
                // C√∫ ph√°p: "C√¢u tho·∫°i": "t√™n_file_√¢m_thanh.mp3"
                "GPU Benchmark initiated. Good luck, Sensei!": "arona_gpu_start.mp3"
                // Th√™m c√°c file gi·ªçng c·ªßa Arona ·ªü ƒë√¢y
            },
            "plana": {
                // Th√™m file gi·ªçng c·ªßa Plana ·ªü ƒë√¢y, v√≠ d·ª•:
                "GPU Benchmark initiated. Good luck, Sensei!": "plana_gpu_start.mp3" 
            }
        };
        const aronaAudioPlayer = new Audio();

        const aiPhrases = [
            "System functioning within normal parameters.",
            "Detecting high GPU usage... impressive.",
            "Don't forget to check the benchmarks.",
            "I am monitoring the Quantum Core for you.",
            "Need a warp jump? Just ask.",
            "The matrix code looks beautiful today.",
            "Sensei, are you still there?",
            "Optimizing render pipeline...",
            "Visuals are stable.",
            "I like this color theme."
        ];

        // --- T√çNH NƒÇNG M·ªöI: Arona Halo Summoning ---
        const aronaHalos = [];
        // TƒÉng k√≠ch th∆∞·ªõc v√† s·ª≠ d·ª•ng depthTest: false ƒë·ªÉ lu√¥n hi·ªÉn th·ªã tr√™n c√πng
        const haloGeo = new THREE.TorusGeometry(12, 0.4, 16, 100);
        const haloMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true, 
            opacity: 0.0,
            side: THREE.DoubleSide,
            depthTest: false, // Hi·ªáu ·ª©ng xuy√™n th·∫•u (Hologram)
            blending: THREE.AdditiveBlending
        });

        function spawnAronaHalo() {
            const halo = new THREE.Mesh(haloGeo, haloMat.clone());
            
            // ƒê·ªïi m√†u Halo d·ª±a tr√™n nh√¢n v·∫≠t (Arona: Xanh, Plana: ƒê·ªè/H·ªìng)
            const color = aiSettings.avatar === 'plana' ? 0xff0040 : 0x00ffff;
            halo.material.color.setHex(color);

            halo.material.opacity = 1;
            halo.position.set(0, 0, 0);
            // Xoay ng·∫´u nhi√™n
            halo.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            halo.userData = { scale: 0.1, growth: 0.1 + Math.random() * 0.1, life: 1.0 };
            scene.add(halo);
            aronaHalos.push(halo);
            sysLog(`${aiSettings.avatar.toUpperCase()}: Halo Field Generated`);
        }

        window.handleAiClick = function() {
            window.triggerAiTalk();
            if (aiSettings.halo) { // Ch·ªâ tri·ªáu h·ªìi n·∫øu ƒë∆∞·ª£c b·∫≠t
                spawnAronaHalo();
            }
        };

        window.triggerAiTalk = function(customMsg) {
            const msg = customMsg || aiPhrases[Math.floor(Math.random() * aiPhrases.length)];
            aiBubble.innerText = msg;
            aiBubble.classList.add('show');
            
            // Ph√°t √¢m thanh n·∫øu c√≥ trong danh s√°ch map
            // Ki·ªÉm tra xem nh√¢n v·∫≠t hi·ªán t·∫°i c√≥ gi·ªçng n√≥i cho c√¢u n√†y kh√¥ng
            if (aiVoiceMap[aiSettings.avatar] && aiVoiceMap[aiSettings.avatar][msg]) {
                aronaAudioPlayer.volume = aiSettings.volume; // √Åp d·ª•ng √¢m l∆∞·ª£ng t·ª´ c√†i ƒë·∫∑t
                // L·∫•y file √¢m thanh ƒë√∫ng cho nh√¢n v·∫≠t ƒëang ƒë∆∞·ª£c ch·ªçn
                aronaAudioPlayer.src = aiVoiceMap[aiSettings.avatar][msg];
                aronaAudioPlayer.play().catch(e => console.warn("Audio play failed:", e));
            }
            
            if(aiTimeout) clearTimeout(aiTimeout);
            aiTimeout = setTimeout(() => {
                aiBubble.classList.remove('show');
            }, 4000);
        };
        
        // --- Logic cho AI Settings ---
        const aiWidget = document.getElementById('ai-widget');
        const toggleAiWidget = document.getElementById('toggle-ai-widget');
        const selectAiAvatar = document.getElementById('select-ai-avatar');
        const toggleAiHalo = document.getElementById('toggle-ai-halo');
        const sliderAiVolume = document.getElementById('slider-ai-volume');
        const toggleCharacterHalo = document.getElementById('toggle-character-halo');
        const colorAiHalo = document.getElementById('color-ai-halo');
        const aiAvatarImg = aiWidget.querySelector('img');
        const characterHalo = aiWidget.querySelector('.ai-halo');

        if (toggleAiWidget) {
            toggleAiWidget.addEventListener('change', (e) => {
                aiWidget.style.display = e.target.checked ? 'flex' : 'none';
            });
        }
        if (selectAiAvatar) {
            selectAiAvatar.addEventListener('change', (e) => {
                aiSettings.avatar = e.target.value;
                if (aiAvatarImg) aiAvatarImg.src = `${aiSettings.avatar}.jpg`;
                
                // C·∫≠p nh·∫≠t c·∫£ avatar trong trang c√†i ƒë·∫∑t
                const settingsAvatarImg = document.querySelector('#ai-settings-overlay .dev-frame img');
                const settingsAvatarName = document.querySelector('#ai-settings-overlay h2');
                if(settingsAvatarImg) settingsAvatarImg.src = `${aiSettings.avatar}.jpg`;
                if(settingsAvatarName) settingsAvatarName.innerText = aiSettings.avatar.toUpperCase();

                // C·∫≠p nh·∫≠t m√†u v√† v·ªã tr√≠ Halo cho nh√¢n v·∫≠t
                if (aiSettings.avatar === 'plana') {
                    aiSettings.haloColor = '#ff0040'; // M√†u h·ªìng c·ªßa Plana
                    if (characterHalo) {
                        characterHalo.style.borderColor = aiSettings.haloColor;
                        characterHalo.style.transform = 'translateX(-10%) rotate(15deg) scale(0.9)';
                    }
                } else { // Arona
                    aiSettings.haloColor = '#00ffff'; // M√†u xanh c·ªßa Arona
                    if (characterHalo) {
                        characterHalo.style.borderColor = aiSettings.haloColor;
                        characterHalo.style.transform = 'translateX(-50%) rotate(-15deg) scale(1.0)';
                    }
                }
                if (colorAiHalo) colorAiHalo.value = aiSettings.haloColor;
            });
        }
        if (toggleAiHalo) {
            toggleAiHalo.addEventListener('change', (e) => {
                aiSettings.halo = e.target.checked;
            });
        }
        if (sliderAiVolume) {
            sliderAiVolume.addEventListener('input', (e) => {
                aiSettings.volume = parseFloat(e.target.value);
            });
        }
        if (toggleCharacterHalo) {
            toggleCharacterHalo.addEventListener('change', (e) => {
                aiSettings.showCharacterHalo = e.target.checked;
                if (characterHalo) characterHalo.style.display = aiSettings.showCharacterHalo ? 'block' : 'none';
            });
        }
        if (colorAiHalo) {
            colorAiHalo.addEventListener('input', (e) => {
                aiSettings.haloColor = e.target.value;
                if (characterHalo) characterHalo.style.borderColor = aiSettings.haloColor;
            });
        }

        // 7. V√≤ng l·∫∑p Animation
        let lastTime = Date.now();
        let accumulatedTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            if (!isGameActive) return; // T·ªëi ∆∞u h√≥a: Ng·ª´ng render khi ·ªü trang ch·ªß

            const now = Date.now();
            const dt = (now - lastTime) * 0.001;
            lastTime = now;

            // V·∫Ω Matrix Rain
            drawMatrixRain();

            // X·ª≠ l√Ω hi·ªáu ·ª©ng Warp
            const targetWarp = isWarping ? 1.0 : 0.0;
            warpFactor += (targetWarp - warpFactor) * 0.05; // Lerp m∆∞·ª£t m√†
            
            // Time Dilation (Slow Motion khi gi·ªØ chu·ªôt tr√°i)
            const timeMultiplier = (isGravityActive === 1) ? 0.1 : 1.0;

            // Bi·∫øn ƒë·ªïi th·ªùi gian d·ª±a tr√™n t·ªëc ƒë·ªô Warp v√† Slow Mo
            const timeScale = (1 + warpFactor * 10) * timeMultiplier * manualTimeScale; 
            accumulatedTime += dt * 0.5 * timeScale;
            const time = accumulatedTime;
            
            // X·ª≠ l√Ω Audio Data
            let bass = 0, mid = 0, high = 0;
            if (audioActive && analyser) {
                analyser.getByteFrequencyData(dataArray);
                // L·∫•y trung b√¨nh c√°c d·∫£i t·∫ßn
                const bassRange = dataArray.slice(0, 10);
                const midRange = dataArray.slice(10, 50);
                const highRange = dataArray.slice(50, 100);
                
                bass = bassRange.reduce((a, b) => a + b, 0) / bassRange.length / 255; // 0.0 - 1.0
                mid = midRange.reduce((a, b) => a + b, 0) / midRange.length / 255;
                high = highRange.reduce((a, b) => a + b, 0) / highRange.length / 255;

                // --- Trigger Audio Pulse on Bass Hit ---
                if (bass > 0.7 && (now - lastPulseTime) > pulseCooldown) {
                    // S·ª≠ d·ª•ng m√†u c·ªßa ƒë√®n bass ƒë·ªÉ t·∫°o xung
                    spawnAudioPulse(pointLight1.color);
                    lastPulseTime = now;
                }
            }

            // Hi·ªáu ·ª©ng Camera FOV (K√©o d√£n kh√¥ng gian)
            const baseFov = 60;
            camera.fov = baseFov + warpFactor * 50; // FOV tƒÉng t·ª´ 60 l√™n 110
            camera.updateProjectionMatrix();

            // Xoay v·∫≠t th·ªÉ ch√≠nh
            torusKnot.rotation.x += 0.005 * timeScale;
            torusKnot.rotation.y += 0.005 * timeScale;

            // Animation cho Quantum Core
            quantumCore.rotation.y -= 0.02;
            quantumCore.rotation.z += 0.01;
            quantumCore.scale.setScalar(1 + Math.sin(time * 10) * 0.05 + bass * 0.5); // Rung ƒë·ªông theo Bass

            // Animation cho Hologram Text
            holoGroup.rotation.y -= 0.005 * timeScale;
            holoGroup.position.y = Math.sin(time * 0.5) * 2; // Bay l√™n xu·ªëng nh·∫π nh√†ng

            // Animation cho Glass Sphere
            glassSphere.rotation.y = -time * 0.1;
            glassSphere.rotation.z = time * 0.05;

            // C·∫≠p nh·∫≠t Shader
            blobMat.uniforms.uTime.value = time;
            blob.rotation.y = time * 0.2;
            
            // Animation Black Hole
            if(isBlackHoleActive) {
                accretionDisk.rotation.z -= 0.1 * timeScale;
                const scale = 1 + Math.sin(time * 10) * 0.05;
                blackHoleMesh.scale.setScalar(scale);
            }

            // Animation cho Supernova
            if (supernovaActive) {
                supernovaTime += dt;
                const scale = 1 + supernovaTime * 150; // N·ªü ra r·∫•t nhanh
                supernovaMesh.scale.setScalar(scale);
                supernovaMat.opacity = Math.max(0, 1 - supernovaTime * 1.5);
                
                // Flash effect (L√†m ch√≥i l√≤a √°nh s√°ng)
                const flashIntensity = Math.max(0, 1 - supernovaTime) * 10;
                bloomPass.strength = 0.2 + flashIntensity; // TƒÉng ƒë·ªô s√°ng Bloom

                if (supernovaMat.opacity <= 0) {
                    supernovaActive = false;
                    supernovaMesh.visible = false;
                    bloomPass.strength = 0.2; // Reset Bloom
                }
            }

            // Animation cho Scanner
            if (isScanning) {
                scanTime += dt;
                scannerPass.uniforms.uTime.value = scanTime;
                if (scanTime > 1.5) { // K·∫øt th√∫c qu√©t (th·ªùi gian > 1.5s ƒë·ªÉ ch·∫°y h·∫øt m√†n h√¨nh)
                    isScanning = false;
                    scannerPass.enabled = false;
                    sysLog("SCAN COMPLETE. NO ANOMALIES.");
                }
            }

            // Animation cho Digital Rain Material
            if(isRainActive) matrixObjMat.uniforms.uTime.value = time;

            // C·∫≠p nh·∫≠t Reflection (·∫®n v·∫≠t th·ªÉ ch√≠nh ƒë·ªÉ kh√¥ng t·ª± ph·∫£n chi·∫øu ch√≠nh n√≥ g√¢y l·ªói h√¨nh ·∫£nh)
            if (isReflectionsEnabled) {
                torusKnot.visible = false;
                cubeCamera.update(renderer, scene);
                if(!isBlackHoleActive) torusKnot.visible = true;
            }

            // C·∫≠p nh·∫≠t Gravity Target (V·ªã tr√≠ chu·ªôt trong kh√¥ng gian 3D)
            gravityPlane.normal.copy(camera.position).normalize(); // M·∫∑t ph·∫≥ng lu√¥n h∆∞·ªõng v·ªÅ camera
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(gravityPlane, gravityTarget);

            // Animation cho Debris (T√≠nh to√°n n·∫∑ng m·ªói khung h√¨nh)
            if (isDebrisEnabled) {
                for (let i = 0; i < debrisCount; i++) {
                    const data = debrisData[i];
                    
                    // --- X·ª≠ l√Ω V·∫≠t l√Ω Gravity ---
                    if (isGravityActive !== 0 && gravityTarget) {
                        // T√≠nh kho·∫£ng c√°ch t·ª´ m·∫£nh v·ª° ƒë·∫øn con tr·ªè chu·ªôt
                        const currentPos = data.initialPos.clone().add(data.physicsPos);
                        const dist = gravityTarget.distanceTo(currentPos);
                        
                        // T√≠nh vector l·ª±c (H√∫t ho·∫∑c ƒê·∫©y)
                        const forceDir = new THREE.Vector3().subVectors(gravityTarget, currentPos).normalize();
                        const force = (5.0 * isGravityActive) / (1 + dist * 0.1); // L·ª±c m·∫°nh h∆°n khi ·ªü g·∫ßn
                        
                        data.velocity.add(forceDir.multiplyScalar(force));
                    }
                    
                    // --- X·ª≠ l√Ω Black Hole Physics ---
                    if (isBlackHoleActive) {
                        const currentPos = data.initialPos.clone().add(data.physicsPos);
                        const dist = currentPos.length();
                        
                        if (dist > 10) { // H√∫t v·ªÅ t√¢m (0,0,0)
                            const forceDir = currentPos.normalize().negate();
                            const force = 10.0 / (1 + dist * 0.01); // L·ª±c h√∫t c·ª±c m·∫°nh
                            data.velocity.add(forceDir.multiplyScalar(force));
                            
                            // T·∫°o xo√°y (Swirl)
                            const swirlDir = new THREE.Vector3(-currentPos.z, 0, currentPos.x).normalize();
                            data.velocity.add(swirlDir.multiplyScalar(force * 0.5));
                        }
                    }

                    // L·ª±c ƒë√†n h·ªìi (K√©o v·ªÅ v·ªã tr√≠ c≈©)
                    data.velocity.add(data.physicsPos.clone().multiplyScalar(-0.05));
                    // Ma s√°t (Gi·∫£m t·ªëc d·∫ßn)
                    data.velocity.multiplyScalar(0.95);
                    // C·∫≠p nh·∫≠t v·ªã tr√≠ v·∫≠t l√Ω
                    data.physicsPos.add(data.velocity);

                    // √Åp d·ª•ng v√†o v·ªã tr√≠ hi·ªÉn th·ªã
                    dummy.position.copy(data.initialPos).add(data.physicsPos);
                    // C·ªông th√™m hi·ªáu ·ª©ng s√≥ng c≈©
                    dummy.position.y += Math.sin(time * 2 + data.offset) * 5;
                    dummy.rotation.x += data.rotSpeed * timeScale;
                    dummy.rotation.y += data.rotSpeed * timeScale;
                    dummy.updateMatrix();
                    debrisMesh.setMatrixAt(i, dummy.matrix);
                }
                debrisMesh.instanceMatrix.needsUpdate = true;
            }

            // Animation cho Neural Lines (K·∫øt n·ªëi c√°c debris ng·∫´u nhi√™n)
            if (isLinesEnabled && isDebrisEnabled) {
                const positions = lineMesh.geometry.attributes.position.array;
                const v1 = new THREE.Vector3();
                const v2 = new THREE.Vector3();
                let lineIdx = 0;
                
                for(let i = 0; i < lineCount; i++) {
                    const idx1 = i % debrisCount;
                    const idx2 = (i + 500) % debrisCount; // Offset kh√°c ƒë·ªÉ n·ªëi xa h∆°n
                    
                    debrisMesh.getMatrixAt(idx1, dummy.matrix);
                    v1.setFromMatrixPosition(dummy.matrix);
                    
                    debrisMesh.getMatrixAt(idx2, dummy.matrix);
                    v2.setFromMatrixPosition(dummy.matrix);

                    positions[lineIdx++] = v1.x; positions[lineIdx++] = v1.y; positions[lineIdx++] = v1.z;
                    positions[lineIdx++] = v2.x; positions[lineIdx++] = v2.y; positions[lineIdx++] = v2.z;
                }
                lineMesh.geometry.attributes.position.needsUpdate = true;
            }

            // Animation cho Menger Sponge
            spongeMesh.rotation.x += 0.001 * timeScale;
            spongeMesh.rotation.y += 0.001 * timeScale;

            // Animation cho Vortex
            for(let i=0; i<vortexCount; i++) {
                const data = vortexData[i];
                data.angle += data.speed * timeScale;
                const r = data.radius + Math.sin(time * 6 + i) * 2; // Gi·ªØ nh·ªãp ƒë·∫≠p ri√™ng (ƒë·ªìng b·ªô v·ªõi time)
                vortexDummy.position.set(Math.cos(data.angle)*r, data.y, Math.sin(data.angle)*r);
                vortexDummy.rotation.x += 0.05;
                vortexDummy.rotation.z += 0.05;
                vortexDummy.updateMatrix();
                vortexMesh.setMatrixAt(i, vortexDummy.matrix);
            }
            vortexMesh.instanceMatrix.needsUpdate = true;

            // Animation cho Floor
            for(let i=0; i<floorSize; i++) {
                for(let j=0; j<floorSize; j++) {
                    const index = i * floorSize + j;
                    floorDummy.position.set((i - floorSize/2) * 5, 0, (j - floorSize/2) * 5);
                    const scaleY = 1 + Math.sin(time * 2 + i * 0.3 + j * 0.3) * 0.8;
                    floorDummy.scale.set(1, scaleY, 1);
                    floorDummy.updateMatrix();
                    floorMesh.setMatrixAt(index, floorDummy.matrix);
                }
            }
            floorMesh.instanceMatrix.needsUpdate = true;

            // Animation cho Satellites
            satellites.forEach(sat => {
                sat.userData.angle += sat.userData.speed * timeScale;
                sat.position.x = Math.cos(sat.userData.angle) * sat.userData.radius;
                sat.position.z = Math.sin(sat.userData.angle) * sat.userData.radius;
                sat.position.y = Math.sin(time + sat.userData.yOffset) * 10;
                sat.lookAt(0, 0, 0);
                sat.rotateZ(time);
            });

            // Animation cho Data Streams
            for(let i=0; i<streamCount; i++) {
                const data = streamData[i];
                data.t += data.speed * timeScale;
                if(data.t > 100) data.t = 0; // Reset khi l√™n ƒë·ªânh

                const angle = data.t * 0.5 + (data.branch * (Math.PI / 2)) + time * 0.2;
                const y = (data.t - 50) * 3;
                
                streamDummy.position.set(Math.cos(angle) * data.radius, y, Math.sin(angle) * data.radius);
                streamDummy.rotation.set(time, time, time);
                streamDummy.updateMatrix();
                streamMesh.setMatrixAt(i, streamDummy.matrix);
            }
            streamMesh.instanceMatrix.needsUpdate = true;

            // Animation cho Dyson Cage
            cageMesh.rotation.y += 0.0005 * timeScale;
            cageMesh.rotation.z += 0.0002 * timeScale;
            cageMesh2.rotation.y -= 0.0007 * timeScale;
            cageMesh2.rotation.x += 0.0005 * timeScale;

            // Animation cho Titan Structure
            titanMesh.rotation.x += 0.001 * timeScale;
            titanMesh.rotation.y -= 0.001 * timeScale;

            // Animation cho Volumetric Beams
            beamMat.uniforms.uTime.value = time;
            beamMesh.rotation.z += 0.002 * timeScale;
            beamMesh2.rotation.z -= 0.003 * timeScale;

            // Animation cho Nano Swarm (T√≠nh to√°n v·ªã tr√≠ cho 10,000 v·∫≠t th·ªÉ)
            for(let i=0; i<swarmCount; i++) {
                const data = swarmData[i];
                // Chuy·ªÉn ƒë·ªông s√≥ng sin ph·ª©c t·∫°p
                const y = Math.sin(time * 2 + data.offset + data.x * 0.05) * 20 + Math.cos(time + data.z * 0.05) * 20;
                swarmDummy.position.set(data.x, y, data.z);
                swarmDummy.rotation.set(time + data.offset, time, 0);
                swarmDummy.updateMatrix();
                swarmMesh.setMatrixAt(i, swarmDummy.matrix);
            }
            swarmMesh.instanceMatrix.needsUpdate = true;

            // Animation cho Tunnel
            tunnel.rotation.y += 0.005 * timeScale;

            // Animation cho Volumetric Fog
            if (isFogEnabled) {
                fogMat.uniforms.uTime.value = time;
            }

            // C·∫≠p nh·∫≠t v·ªã tr√≠ ngu·ªìn s√°ng cho God Rays Pass
            // Chi·∫øu v·ªã tr√≠ c·ªßa Quantum Core (0,0,0) l√™n m√†n h√¨nh 2D
            const corePos = new THREE.Vector3(0, 0, 0);
            corePos.project(camera);
            // Chuy·ªÉn t·ª´ to·∫° ƒë·ªô clip space (-1 ƒë·∫øn 1) sang UV space (0 ƒë·∫øn 1)
            const x = (corePos.x + 1) / 2;
            const y = (corePos.y + 1) / 2;
            godRaysPass.uniforms.fX.value = x;
            godRaysPass.uniforms.fY.value = y;

            // C·∫≠p nh·∫≠t ti√™u c·ª± cho Bokeh (t·ª± ƒë·ªông l·∫•y n√©t v√†o t√¢m)
            bokehPass.uniforms['focus'].value = camera.position.length();

            // Hi·ªáu ·ª©ng RGB Shift ƒë·∫≠p theo nh·ªãp
            effectShift.uniforms['amount'].value = 0.0015 + (Math.sin(time * 5) * 0.001) + (warpFactor * 0.02) + (high * 0.01); // TƒÉng m·∫°nh khi Warp v√† High freq

            // Animation cho c√°c v√≤ng nh·∫´n
            rings.forEach((ring, i) => {
                ring.rotation.x += 0.002 * (i + 1);
                ring.rotation.y += 0.002 * (i + 1);
            });

            // Animation cho tinh th·ªÉ
            crystals.forEach(c => {
                c.mesh.rotation.x += c.speed;
                c.mesh.rotation.y += c.speed;
                c.mesh.position.y += Math.sin(time * 2 + c.offset) * 0.05; // Nh·∫•p nh√¥ nh·∫π
            });

            // Di chuy·ªÉn ƒë√®n xung quanh
            pointLight1.position.x = Math.sin(time * 0.7) * (30 + bass * 20); // ƒê√®n di chuy·ªÉn r·ªông h∆°n khi c√≥ bass
            pointLight1.position.y = Math.cos(time * 0.5) * 40;
            pointLight1.position.z = Math.cos(time * 0.3) * 30;

            pointLight2.position.x = Math.cos(time * 0.3) * 30;
            pointLight2.position.y = Math.sin(time * 0.5) * 40;
            pointLight2.position.z = Math.sin(time * 0.7) * (30 + mid * 20);

            // Xoay nh·∫π h·ªá th·ªëng h·∫°t
            particlesMesh.rotation.y -= 0.001 * timeScale;
            
            // Hi·ªáu ·ª©ng Star Streak (K√©o d√†i ng√¥i sao khi Warp)
            // K√©o d√†i tr·ª•c Z v√† h∆∞·ªõng n√≥ v·ªÅ ph√≠a camera ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng bay xuy√™n qua
            particlesMesh.scale.z = 1 + warpFactor * 50; 

            // Animation cho Energy Pulses
            for (let i = audioPulses.length - 1; i >= 0; i--) {
                const pulse = audioPulses[i];
                const maxLife = 2000; // 2 gi√¢y
                const elapsed = now - pulse.startTime;
                const progress = elapsed / maxLife;

                if (progress >= 1) {
                    pulseGroup.remove(pulse.mesh);
                    pulse.mesh.geometry.dispose();
                    pulse.mesh.material.dispose();
                    audioPulses.splice(i, 1);
                } else {
                    const scale = 1 + progress * 100; // Lan r·ªông t·ªõi b√°n k√≠nh 100
                    pulse.mesh.scale.setScalar(scale);
                    pulse.mesh.material.opacity = 0.8 * (1 - Math.pow(progress, 2)); // M·ªù d·∫ßn (ease-out)
                    pulse.mesh.lookAt(camera.position); // Lu√¥n h∆∞·ªõng v·ªÅ camera
                }
            }

            // Animation cho Arona Halos
            for (let i = aronaHalos.length - 1; i >= 0; i--) {
                const h = aronaHalos[i];
                h.userData.scale += h.userData.growth;
                h.scale.setScalar(h.userData.scale);
                h.userData.life -= 0.015;
                h.material.opacity = h.userData.life;
                h.rotation.x += 0.02; h.rotation.y += 0.02;
                if (h.userData.life <= 0) {
                    scene.remove(h);
                    h.geometry.dispose(); h.material.dispose();
                    aronaHalos.splice(i, 1);
                }
            }

            if (isDirectorMode) {
                updateDirector();
            } else {
                controls.update(); // C·∫≠p nh·∫≠t controls th·ªß c√¥ng
            }
            
            // Logic Benchmark
            if(isBenchmarking) {
                benchFrames++;
                benchFrameTimes.push(dt);
                const elapsed = performance.now() - benchStartTime;
                if(elapsed >= 10000) { // Ch·∫°y trong 10 gi√¢y
                    finishBenchmark(elapsed);
                }
            }

            // Random System Logs (T·∫°o c·∫£m gi√°c h·ªá th·ªëng ƒëang ho·∫°t ƒë·ªông ng·∫ßm)
            if (Math.random() < 0.002) {
                const msgs = ["Optimizing Shaders...", "Garbage Collection...", "Syncing Particles...", "Ping: 1ms", "Vortex Stable"];
                sysLog(msgs[Math.floor(Math.random() * msgs.length)]);
            }

            stats.update();    // C·∫≠p nh·∫≠t FPS
            statsMem.update(); // C·∫≠p nh·∫≠t Memory
            // renderer.render(scene, camera); // Thay th·∫ø b·∫±ng composer ƒë·ªÉ c√≥ hi·ªáu ·ª©ng Bloom
            composer.render();
        }

        // 8. X·ª≠ l√Ω khi thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ª≠a s·ªï
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            sharpenPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight); // C·∫≠p nh·∫≠t resolution cho Sharpen
            
            // Resize Matrix Rain
            matrixCanvas.width = window.innerWidth;
            matrixCanvas.height = window.innerHeight;
            matrixContext.fillStyle = '#000';
            matrixContext.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
            matrixColumns = Math.floor(window.innerWidth / matrixFontSize);
            for(let i = 0; i < matrixColumns; i++) {
                if(!matrixDrops[i]) matrixDrops[i] = 1;
            }

            // C·∫≠p nh·∫≠t th√¥ng tin ƒë·ªô ph√¢n gi·∫£i trong GPU Info
            const gpuDiv = document.getElementById('gpu-info');
            if(gpuDiv) gpuDiv.innerHTML = `GPU: ${rendererInfo}<br>Res: ${window.innerWidth}x${window.innerHeight}`;
        }

        animate();
    </script>
</body>
</html>