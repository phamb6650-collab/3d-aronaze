<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex 3D Scene with Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Ẩn thanh cuộn */
            background-color: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
            touch-action: none; /* Ngăn cuộn trang trên mobile khi chạm vào canvas */
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        .quality-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 5px;
            z-index: 1000;
        }
        .quality-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 12px;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.3s;
        }
        .quality-btn:hover, .quality-btn.active {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 15px #00ffff;
        }
        #transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            opacity: 0;
            pointer-events: none;
            z-index: 2000;
            transition: opacity 0.5s ease-in-out;
        }
        #warp-btn {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff0040;
            color: #ff0040;
            padding: 15px 40px;
            font-size: 20px;
            font-family: monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
            letter-spacing: 4px;
        }
        #warp-btn:hover, #warp-btn.active {
            background: #ff0040;
            color: #000;
            box-shadow: 0 0 30px #ff0040;
        }
        #audio-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 15px 20px;
            font-size: 16px;
            font-family: monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
        }
        #audio-btn:hover, #audio-btn.active {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 30px #00ff00;
        }
        #director-btn {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(255, 165, 0, 0.2);
            border: 2px solid #ffa500;
            color: #ffa500;
            padding: 10px 15px;
            font-size: 14px;
            font-family: monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1600; /* Cao hơn Cinematic Bars để luôn bấm được */
        }
        #director-btn:hover, #director-btn.active {
            background: #ffa500;
            color: #000;
            box-shadow: 0 0 20px #ffa500;
        }
        
        #benchmark-btn {
            position: absolute;
            top: 130px;
            left: 20px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 15px;
            font-size: 14px;
            font-family: monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
        }
        #benchmark-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff;
        }
        #benchmark-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 40px;
            color: #00ffff;
            font-family: monospace;
            text-align: center;
            z-index: 3000;
            display: none;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
            min-width: 300px;
        }
        
        /* --- Cinematic Bars --- */
        .cinematic-bar {
            position: fixed;
            left: 0;
            width: 100%;
            height: 0;
            background-color: black;
            z-index: 1500; /* Che các nút khác nhưng nằm dưới transition overlay */
            transition: height 0.8s ease-in-out;
        }
        #cinematic-bar-top { top: 0; }
        #cinematic-bar-bottom { bottom: 0; }

        /* --- Mobile Optimization --- */
        @media (max-width: 768px) {
            .quality-controls {
                top: 10px;
                right: 5px;
                left: 5px;
                justify-content: center;
                flex-wrap: wrap;
                gap: 4px;
            }
            .quality-btn {
                padding: 6px 8px;
                font-size: 11px;
                flex: 1 0 auto; /* Tự động co giãn */
                text-align: center;
            }
            #warp-btn {
                bottom: 50px; /* Nâng lên để tránh thanh điều hướng iOS/Android */
                width: 80%;
                font-size: 16px;
                padding: 12px 0;
            }
            #audio-btn {
                bottom: 110px; /* Nằm trên nút Warp */
                right: 50%;
                transform: translateX(50%);
                width: 80%;
                text-align: center;
            }
            #director-btn {
                top: auto;
                bottom: 170px; /* Xếp chồng lên trên audio btn */
                right: 50%;
                transform: translateX(50%);
                width: 80%;
                text-align: center;
                left: auto;
            }
            #benchmark-btn {
                top: auto;
                bottom: 230px; /* Xếp chồng lên trên director btn */
                left: 50%;
                transform: translateX(-50%);
                width: 80%;
                text-align: center;
            }
        }

        /* --- Landing Screen & CPU Test --- */
        #landing-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            backdrop-filter: blur(10px);
            flex-wrap: wrap;
        }
        .choice-card {
            width: 280px;
            height: 350px;
            border: 2px solid #00ffff;
            background: rgba(0, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
            color: #00ffff;
            font-family: monospace;
            text-align: center;
        }
        .choice-card:hover {
            background: #00ffff;
            color: #000;
            transform: scale(1.05);
            box-shadow: 0 0 40px #00ffff;
        }
        .choice-card h1 { font-size: 36px; margin: 0 0 10px 0; line-height: 1.2; }
        .choice-card p { font-size: 14px; opacity: 0.7; letter-spacing: 1px; }

        #cpu-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #111;
            z-index: 9999;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ff0040;
            font-family: monospace;
        }
        .cpu-bar-bg { width: 60%; height: 20px; background: #333; margin: 20px 0; border: 1px solid #ff0040; }
        .cpu-bar-fill { height: 100%; background: #ff0040; width: 0%; transition: width 0.1s; }
        
        /* Class để ẩn UI game khi ở menu */
        .game-ui { display: none !important; }

        /* --- Leaderboard --- */
        .leaderboard {
            margin-top: 20px;
            width: 90%;
            max-width: 600px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #555;
            color: #fff;
            font-weight: bold;
            text-transform: uppercase;
            background: rgba(0, 0, 0, 0.3);
        }
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid #222;
            color: #aaa;
            font-family: monospace;
            transition: background 0.2s;
        }
        .leaderboard-item:hover { background: rgba(255, 255, 255, 0.05); }
        .leaderboard-item.user {
            color: #00ff00;
            font-weight: bold;
            background: rgba(0, 255, 0, 0.15);
            border: 1px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            transform: scale(1.02);
            margin: 5px 0;
        }
        .leaderboard-rank { width: 40px; text-align: left; }
        .leaderboard-name { flex-grow: 1; text-align: left; }
        .leaderboard-score { width: 100px; text-align: right; }

        /* --- TÍNH NĂNG MỚI: System Log & Tools --- */
        #system-log {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 280px;
            height: 150px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #00ff00;
            text-shadow: 0 0 2px #00ff00;
            pointer-events: none;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            z-index: 900;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            padding: 10px;
            border-left: 1px solid rgba(0, 255, 0, 0.3);
            mask-image: linear-gradient(to bottom, transparent, black 20%);
        }
        .log-entry { margin-top: 2px; opacity: 0.8; }
        .log-entry::before { content: "> "; color: #00ffff; }
        
        #tools-panel {
            position: absolute;
            top: 180px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
            width: 150px;
        }
        .tool-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #555;
            padding: 5px 8px;
            color: #00ffff;
            font-size: 11px;
        }
        input[type=range] {
            width: 80px;
            height: 4px;
            accent-color: #00ffff;
            cursor: pointer;
        }
        #theme-select {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #555;
            color: #00ffff;
            font-family: monospace;
            font-size: 11px;
            width: 80px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="loading">Đang tải tài nguyên 3D...</div>
    <div id="transition-overlay"></div>
    <div id="cinematic-bar-top" class="cinematic-bar"></div>
    <div id="cinematic-bar-bottom" class="cinematic-bar"></div>

    <!-- LANDING SCREEN -->
    <div id="landing-screen">
        <div class="choice-card" onclick="startBenchmarkMode()">
            <h1>3D<br>BENCHMARK</h1>
            <p>GPU STRESS TEST</p>
        </div>
        <div class="choice-card" style="border-color: #ff0040; color: #ff0040; background: rgba(255,0,64,0.05);" onclick="startCpuMode()">
            <h1 style="color: inherit;">CPU<br>TEST</h1>
            <p>MULTI-CORE CHIP TEST</p>
        </div>
    </div>

    <!-- CPU TEST SCREEN -->
    <div id="cpu-screen">
        <h1 id="cpu-status" style="font-size: 24px;">CPU RAYTRACING BENCHMARK</h1>
        <div id="cpu-system-info" style="color: #00ffff; margin-bottom: 10px; font-size: 14px; text-align: center; font-family: monospace;"></div>
        
        <div id="cpu-controls" style="margin-bottom: 15px; display: flex; gap: 10px; z-index: 10000;">
            <select id="cpu-res-select" style="background: rgba(0,0,0,0.8); color: #00ffff; border: 1px solid #00ffff; padding: 8px; font-family: monospace; cursor: pointer;">
                <option value="640x360">SD (640x360)</option>
                <option value="1280x720">HD (1280x720)</option>
                <option value="1920x1080">Full HD (1920x1080)</option>
                <option value="3840x2160">4K (3840x2160)</option>
            </select>
            <button id="cpu-start-btn" class="quality-btn" style="border-color: #00ff00; color: #00ff00;">START TEST</button>
        </div>

        <div style="display: flex; gap: 20px; margin-bottom: 10px;">
            <div id="score-single" style="border: 1px solid #555; padding: 10px; width: 150px; text-align: center;">
                <div style="font-size: 12px; color: #888;">SINGLE-CORE</div>
                <div class="val" style="font-size: 24px; font-weight: bold; color: #fff;">---</div>
            </div>
            <div id="score-multi" style="border: 1px solid #555; padding: 10px; width: 150px; text-align: center;">
                <div style="font-size: 12px; color: #888;">MULTI-CORE</div>
                <div class="val" style="font-size: 24px; font-weight: bold; color: #fff;">---</div>
            </div>
        </div>

        <canvas id="cpu-render-canvas" width="640" height="360" style="max-width: 90vw; max-height: 50vh; width: auto; height: auto; background: #000; border: 1px solid #333; image-rendering: pixelated;"></canvas>
        <div class="cpu-bar-bg" style="width: 90%; max-width: 640px; margin: 10px 0;"><div class="cpu-bar-fill" id="cpu-progress"></div></div>
        
        <div id="cpu-results" style="text-align: center; font-size: 16px; line-height: 1.6; color: #fff;"></div>
        <canvas id="cpu-chart-canvas" width="600" height="400" style="width: 90%; max-width: 600px; margin-top: 20px; background: rgba(0,0,0,0.3); border: 1px solid #333; display: none;"></canvas>
        <button class="quality-btn" style="margin-top: 20px; border-color: #fff; color: #fff;" onclick="location.reload()">RETURN TO MENU</button>
    </div>

    <div id="benchmark-modal">
        <h2 style="margin-top: 0; color: #fff;">SYSTEM ANALYSIS COMPLETE</h2>
        <div style="font-size: 14px; color: #888; margin-bottom: 10px;">PERFORMANCE SCORE</div>
        <div id="benchmark-score" style="font-size: 60px; font-weight: bold; margin: 20px 0; text-shadow: 0 0 20px #00ffff; color: #fff;">0</div>
        <div id="benchmark-fps" style="font-size: 20px; margin-bottom: 20px;">AVG FPS: 0</div>
        <button onclick="document.getElementById('benchmark-modal').style.display='none'" class="quality-btn" style="width: 100%;">CLOSE</button>
    </div>
    <div class="game-ui" style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #888; font-size: 12px; pointer-events: none; z-index: 1000; text-shadow: 0 0 5px #000;">[Left Click] Attract (Release for Shockwave) | [Right Click] Repel</div>
    
    <div class="quality-controls game-ui">
        <button class="quality-btn" onclick="window.setQuality(0)">Super Low</button>
        <button class="quality-btn active" onclick="window.setQuality(1)">Low</button>
        <button class="quality-btn" onclick="window.setQuality(2)">Medium</button>
        <button class="quality-btn" onclick="window.setQuality(3)">High</button>
        <button class="quality-btn" onclick="window.setQuality(4)">Ultra</button>
        <button class="quality-btn" onclick="window.setQuality(5)">Extreme</button>
    </div>

    <button id="warp-btn" class="game-ui">ENGAGE WARP</button>
    <button id="audio-btn" class="game-ui">ENABLE MIC</button>
    <button id="director-btn" class="game-ui">AUTO DIRECTOR</button>
    <button id="benchmark-btn" class="game-ui">RUN BENCHMARK</button>

    <!-- TÍNH NĂNG MỚI: Tools Panel & System Log -->
    <div id="tools-panel" class="game-ui">
        <div class="tool-row">
            <span>TIME SCALE</span>
            <input type="range" id="time-slider" min="0" max="3" step="0.1" value="1">
        </div>
        <div class="tool-row">
            <span>THEME</span>
            <select id="theme-select">
                <option value="cyberpunk">CYBERPUNK</option>
                <option value="matrix">MATRIX</option>
                <option value="inferno">INFERNO</option>
            </select>
        </div>
        <button id="glitch-btn" class="quality-btn" style="width: 100%; text-align: center; margin-top: 5px;">TRIGGER GLITCH</button>
        <button id="blackhole-btn" class="quality-btn" style="width: 100%; text-align: center; margin-top: 5px; border-color: #ff00ff; color: #ff00ff;">ACTIVATE BLACK HOLE</button>
        <button id="supernova-btn" class="quality-btn" style="width: 100%; text-align: center; margin-top: 5px; border-color: #ffaa00; color: #ffaa00;">TRIGGER SUPERNOVA (SPACE)</button>
        <button id="scan-btn" class="quality-btn" style="width: 100%; text-align: center; margin-top: 5px; border-color: #00ffff; color: #00ffff;">SYSTEM SCAN</button>
        <button id="rain-btn" class="quality-btn" style="width: 100%; text-align: center; margin-top: 5px; border-color: #00ff00; color: #00ff00;">DIGITAL RAIN</button>
        <button id="wireframe-btn" class="quality-btn" style="width: 100%; text-align: center; margin-top: 5px; border-color: #ffffff; color: #ffffff;">WIREFRAME MODE</button>
        <button id="screenshot-btn" class="quality-btn" style="width: 100%; text-align: center;">SCREENSHOT</button>
    </div>
    <div id="system-log" class="game-ui"></div>

    <!-- Import map để load Three.js từ CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import Stats from 'three/addons/libs/stats.module.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
        import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
        import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
        import { GodRaysFakeSunShader, GodRaysDepthMaskShader, GodRaysGenerateShader, GodRaysCombineShader } from 'three/addons/shaders/GodRaysShader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // 1. Cấu hình cơ bản (Scene, Camera, Renderer)
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        // --- TÍNH NĂNG MỚI: Matrix Rain Background ---
        const matrixCanvas = document.createElement('canvas');
        matrixCanvas.width = window.innerWidth;
        matrixCanvas.height = window.innerHeight;
        const matrixContext = matrixCanvas.getContext('2d');
        
        // Khởi tạo nền đen
        matrixContext.fillStyle = '#000';
        matrixContext.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);

        const matrixTexture = new THREE.CanvasTexture(matrixCanvas);
        scene.background = matrixTexture;

        const matrixFontSize = 14;
        let matrixColumns = Math.floor(window.innerWidth / matrixFontSize);
        const matrixDrops = [];
        for(let i = 0; i < matrixColumns; i++) {
            matrixDrops[i] = 1;
        }
        const matrixChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()ｦｧｨｩｪｫｬｭｮｯｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ";
        let matrixColor = '#00ff00'; // Biến lưu màu Matrix

        function drawMatrixRain() {
            // Hiệu ứng mờ dần (Trails)
            matrixContext.fillStyle = 'rgba(0, 0, 0, 0.05)'; 
            matrixContext.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
            
            matrixContext.fillStyle = matrixColor; // Sử dụng biến màu động
            matrixContext.font = matrixFontSize + 'px monospace';
            
            for(let i = 0; i < matrixDrops.length; i++) {
                const text = matrixChars.charAt(Math.floor(Math.random() * matrixChars.length));
                matrixContext.fillText(text, i * matrixFontSize, matrixDrops[i] * matrixFontSize);
                
                // Reset ngẫu nhiên khi chạm đáy
                if(matrixDrops[i] * matrixFontSize > matrixCanvas.height && Math.random() > 0.975)
                    matrixDrops[i] = 0;
                
                matrixDrops[i]++;
            }
            matrixTexture.needsUpdate = true;
        }

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 0, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Giới hạn pixel ratio tối đa là 2 để tối ưu hiệu năng mobile
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.5; // Giảm độ phơi sáng tổng thể
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 2. Thêm FPS Counter (Stats)
        const stats = new Stats();
        stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
        
        // Tùy chỉnh style cho Stats dựa trên thiết bị
        const isMobile = window.innerWidth < 768;
        const statsScale = isMobile ? '1.0' : '1.5'; // Mobile thì nhỏ lại
        
        // Chuyển xuống góc dưới bên trái
        stats.dom.style.cssText = `position:fixed;bottom:0px;left:0px;cursor:pointer;opacity:0.9;z-index:10000;transform:scale(${statsScale});transform-origin:bottom left;`;
        
        // Ẩn Stats ban đầu
        stats.dom.style.display = 'none';
        document.body.appendChild(stats.dom);

        // --- TÍNH NĂNG MỚI: Memory Stats (Biểu đồ bộ nhớ) ---
        const statsMem = new Stats();
        statsMem.showPanel(2); // 0: fps, 1: ms, 2: mb
        const statsWidth = 80 * parseFloat(statsScale);
        statsMem.dom.style.cssText = `position:fixed;bottom:0px;left:${statsWidth}px;cursor:pointer;opacity:0.9;z-index:10000;transform:scale(${statsScale});transform-origin:bottom left;`;
        
        // Ẩn Stats ban đầu
        statsMem.dom.style.display = 'none';
        document.body.appendChild(statsMem.dom);

        // --- TÍNH NĂNG MỚI: Hiển thị thông tin GPU ---
        const gl = renderer.getContext();
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        const rendererInfo = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown GPU';
        
        const gpuDiv = document.createElement('div');
        gpuDiv.id = 'gpu-info';
        // Tính toán vị trí bên cạnh Stats (FPS + Mem)
        const totalStatsWidth = statsWidth * 2;
        gpuDiv.style.cssText = `position:fixed;bottom:0px;left:${totalStatsWidth}px;color:#00ffff;font-family:monospace;font-size:11px;background:rgba(0,0,0,0.7);padding:4px 8px;border:1px solid #00ffff;pointer-events:none;z-index:10000;white-space:nowrap;`;
        gpuDiv.innerHTML = `GPU: ${rendererInfo}<br>Res: ${window.innerWidth}x${window.innerHeight}`;
        
        // Ẩn GPU Info ban đầu
        gpuDiv.style.display = 'none';
        document.body.appendChild(gpuDiv);

        // 3. Điều khiển Camera (OrbitControls)
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 80; // Giới hạn zoom xa chặt hơn để tập trung vào cảnh chính
        controls.minDistance = 20;  // Giới hạn zoom gần để không xuyên qua vật thể
        controls.maxPolarAngle = Math.PI / 1.5; // Giới hạn góc nhìn từ dưới lên
        controls.minPolarAngle = Math.PI / 6;   // Giới hạn góc nhìn từ trên xuống

        // --- NÂNG CẤP: Post-processing (Hiệu ứng Bloom phát sáng) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.6; // Tăng ngưỡng để chỉ vùng rất sáng mới phát quang
        bloomPass.strength = 0.2;  // Giảm độ mạnh để bớt chói
        bloomPass.radius = 0.5;    // Bán kính lan tỏa
        
        const afterimagePass = new AfterimagePass();
        afterimagePass.uniforms['damp'].value = 0.85; // Tạo hiệu ứng bóng mờ (trails)
        
        // --- NÂNG CẤP: Cinematic Effects (Hiệu ứng điện ảnh) ---
        const effectFilm = new FilmPass(0.35, 0.025, 648, false); // Nhiễu hạt và scanlines
        
        const effectShift = new ShaderPass(RGBShiftShader); // Tách màu RGB
        effectShift.uniforms['amount'].value = 0.0015;

        // --- NÂNG CẤP: Depth of Field (Bokeh) ---
        const bokehPass = new BokehPass(scene, camera, {
            focus: 50.0,
            aperture: 0.0001,
            maxblur: 0.01,
        });
        bokehPass.enabled = false; // Mặc định tắt (Low setting)

        // --- NÂNG CẤP: SSAO (Screen Space Ambient Occlusion) - Hiệu ứng bóng đổ khe kẽ cực nặng ---
        const ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
        ssaoPass.kernelRadius = 16; // Bán kính bóng đổ
        ssaoPass.minDistance = 0.005;
        ssaoPass.maxDistance = 0.1;
        ssaoPass.enabled = false; // Mặc định tắt (Low setting)

        // --- NÂNG CẤP: God Rays Pass (Tia sáng thần thánh) ---
        // Shader tùy chỉnh để tạo hiệu ứng Radial Blur (God Rays) từ tâm
        const godRaysShader = {
            uniforms: {
                tDiffuse: { value: null },
                fX: { value: 0.5 }, // Tọa độ X của nguồn sáng trên màn hình
                fY: { value: 0.5 }, // Tọa độ Y của nguồn sáng trên màn hình
                fExposure: { value: 0.3 },
                fDecay: { value: 0.93 },
                fDensity: { value: 0.5 },
                fWeight: { value: 0.4 },
                fClamp: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                varying vec2 vUv;
                uniform float fX; uniform float fY; uniform float fExposure; uniform float fDecay; uniform float fDensity; uniform float fWeight; uniform float fClamp;
                void main() {
                    vec2 deltaTextCoord = vec2( vUv.x - fX, vUv.y - fY );
                    deltaTextCoord *= 1.0 / float( 100 ) * fDensity;
                    vec2 coord = vUv;
                    vec4 fragColor = texture2D( tDiffuse, vUv );
                    float illuminationDecay = 1.0;
                    for(int i=0; i < 75 ; i++){ // Loop nặng để tạo tia sáng mượt
                        coord -= deltaTextCoord;
                        vec4 texel = texture2D( tDiffuse, coord );
                        texel *= illuminationDecay * fWeight;
                        fragColor += texel;
                        illuminationDecay *= fDecay;
                    }
                    gl_FragColor = fragColor * fExposure;
                }
            `
        };
        const godRaysPass = new ShaderPass(new THREE.ShaderMaterial(godRaysShader));
        godRaysPass.needsSwap = true;
        godRaysPass.enabled = false; // Mặc định tắt (Low setting)

        // --- NÂNG CẤP: Sharpen Shader (Làm nét hình ảnh cực đại) ---
        const SharpenShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "amount": { value: 0.3 }, // Độ sắc nét (0.0 - 1.0)
                "resolution": { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float amount;
                uniform vec2 resolution;
                varying vec2 vUv;
                void main() {
                    vec2 step = 1.0 / resolution;
                    vec4 color = texture2D( tDiffuse, vUv );
                    vec4 colorLeft = texture2D( tDiffuse, vUv + vec2( -step.x, 0.0 ) );
                    vec4 colorRight = texture2D( tDiffuse, vUv + vec2( step.x, 0.0 ) );
                    vec4 colorTop = texture2D( tDiffuse, vUv + vec2( 0.0, step.y ) );
                    vec4 colorBottom = texture2D( tDiffuse, vUv + vec2( 0.0, -step.y ) );
                    vec4 sum = color * 5.0 - colorLeft - colorRight - colorTop - colorBottom;
                    gl_FragColor = mix(color, sum, amount);
                }
            `
        };
        const sharpenPass = new ShaderPass(new THREE.ShaderMaterial(SharpenShader));
        sharpenPass.enabled = false; // Mặc định tắt (Low setting)

        // --- NÂNG CẤP: Lens Dirt Effect (Bụi ống kính) ---
        function createDirtTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 512, 512);
            
            // Vẽ các đốm bụi/bẩn ngẫu nhiên
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const r = Math.random() * 30 + 5;
                const opacity = Math.random() * 0.2 + 0.05;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                grad.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }

        const LensDirtShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "tDirt": { value: createDirtTexture() },
                "intensity": { value: 2.0 }
            },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
            fragmentShader: `uniform sampler2D tDiffuse; uniform sampler2D tDirt; uniform float intensity; varying vec2 vUv; void main() { vec4 texel = texture2D( tDiffuse, vUv ); vec4 dirt = texture2D( tDirt, vUv ); float luminance = dot(texel.rgb, vec3(0.2126, 0.7152, 0.0722)); gl_FragColor = texel + (dirt * texel * smoothstep(0.2, 0.8, luminance) * intensity); }`
        };
        const lensDirtPass = new ShaderPass(new THREE.ShaderMaterial(LensDirtShader));
        lensDirtPass.enabled = false;

        // --- TÍNH NĂNG MỚI: Scanner Effect (Quét không gian) ---
        const ScannerShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "uTime": { value: 0 },
                "uColor": { value: new THREE.Color(0x00ffff) },
                "uWidth": { value: 0.05 } // Độ rộng chùm quét
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float uTime;
                uniform vec3 uColor;
                uniform float uWidth;
                varying vec2 vUv;
                
                void main() {
                    vec4 texel = texture2D( tDiffuse, vUv );
                    
                    // Tính toán vị trí quét (chạy từ -0.5 đến 1.5)
                    float scanPos = uTime * 1.5 - 0.25;
                    
                    // Tạo độ cong nhẹ cho vạch quét giống như đang quét khối cầu
                    float curve = sin(vUv.y * 3.14159) * 0.1;
                    float dist = abs(vUv.x - scanPos - curve);
                    
                    if (dist < uWidth) {
                        float intensity = 1.0 - (dist / uWidth);
                        intensity = pow(intensity, 2.0); // Làm mềm biên
                        float scanline = sin(vUv.y * 500.0) * 0.1; // Sọc ngang
                        vec3 scanColor = uColor * (intensity + scanline);
                        gl_FragColor = vec4(texel.rgb + scanColor, texel.a);
                    } else {
                        gl_FragColor = texel;
                    }
                }
            `
        };
        const scannerPass = new ShaderPass(new THREE.ShaderMaterial(ScannerShader));
        scannerPass.enabled = false;

        // --- TÍNH NĂNG MỚI: Glitch Pass (Hiệu ứng nhiễu sóng) ---
        const glitchPass = new GlitchPass();
        glitchPass.enabled = false; // Mặc định tắt
        glitchPass.goWild = false;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(ssaoPass); // Thêm SSAO vào pipeline
        composer.addPass(godRaysPass); // Thêm God Rays sau SSAO
        composer.addPass(afterimagePass);
        composer.addPass(bloomPass);
        composer.addPass(lensDirtPass); // Thêm Lens Dirt sau Bloom
        composer.addPass(bokehPass);
        composer.addPass(effectFilm);
        composer.addPass(effectShift);
        composer.addPass(sharpenPass); // Thêm Sharpen vào cuối cùng
        composer.addPass(scannerPass); // Scanner đè lên
        composer.addPass(glitchPass); // Glitch đè lên tất cả

        // --- NÂNG CẤP: Real-time Reflections (CubeCamera) ---
        // Render cảnh xung quanh vào texture để vật thể phản chiếu (Rất nặng cho GPU)
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024); // Tăng độ phân giải phản chiếu lên 1024 (Siêu nét)
        cubeRenderTarget.texture.type = THREE.HalfFloatType;
        const cubeCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);
        scene.add(cubeCamera);

        // 4. Tạo vật thể chính: Complex Torus Knot
        // Lớp bên trong (Solid)
        const geometry = new THREE.TorusKnotGeometry(10, 3, 300, 32); // Mặc định Low Poly
        const material = new THREE.MeshPhysicalMaterial({ 
            color: 0x156289, 
            roughness: 0.05, // Bóng loáng để phản chiếu rõ nét
            metalness: 1.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            flatShading: false,
            envMap: cubeRenderTarget.texture // Áp dụng texture phản chiếu thời gian thực
        });
        const torusKnot = new THREE.Mesh(geometry, material);
        torusKnot.castShadow = true;
        torusKnot.receiveShadow = true;
        scene.add(torusKnot);

        // Lớp bên ngoài (Wireframe)
        const wireframeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.1 }); // Giảm opacity để nhìn rõ lõi
        const wireframeMesh = new THREE.Mesh(geometry, wireframeMat);
        wireframeMesh.scale.setScalar(1.05); // Lớn hơn một chút để bao bọc
        torusKnot.add(wireframeMesh);

        // --- NÂNG CẤP: Quantum Core (Lõi lượng tử trung tâm) ---
        // Một khối cầu dây cực kỳ chi tiết xoay nhanh ở giữa
        const coreGeo = new THREE.IcosahedronGeometry(5, 6); // Detail level 6 = rất nhiều tam giác
        const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 });
        const quantumCore = new THREE.Mesh(coreGeo, coreMat);
        scene.add(quantumCore);

        // --- TÍNH NĂNG MỚI: Hologram Text (Văn bản 3D) ---
        const holoGroup = new THREE.Group();
        scene.add(holoGroup);

        const fontLoader = new FontLoader();
        // Load font từ URL CDN
        fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
            const texts = ["QUANTUM", "CORE", "SYSTEM", "STABLE"];
            const textMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.6,
                wireframe: true, // Hiệu ứng khung dây hologram
                side: THREE.DoubleSide
            });

            texts.forEach((str, i) => {
                const textGeo = new TextGeometry(str, {
                    font: font,
                    size: 1.5,
                    height: 0.1, // Độ dày
                    curveSegments: 4,
                    bevelEnabled: false
                });
                
                // Căn giữa văn bản
                textGeo.computeBoundingBox();
                const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
                textGeo.translate(centerOffset, 0, 0);

                const textMesh = new THREE.Mesh(textGeo, textMat);
                
                // Xếp thành vòng tròn quanh lõi
                const angle = (i / texts.length) * Math.PI * 2;
                const radius = 12; // Bán kính quỹ đạo
                textMesh.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                textMesh.lookAt(0, 0, 0); 
                textMesh.rotation.y += Math.PI; // Quay ngược lại để mặt chữ hướng ra ngoài

                holoGroup.add(textMesh);
            });
        });

        // --- NÂNG CẤP: Glass Shield (Lớp khiên thủy tinh khúc xạ) ---
        // Vật liệu vật lý với tính chất khúc xạ và tán sắc ánh sáng (Rất nặng xử lý)
        const glassGeo = new THREE.IcosahedronGeometry(7, 6); // Tăng detail lên 6 (Rất mịn)
        const glassMat = new THREE.MeshPhysicalMaterial({
            roughness: 0.1,
            transmission: 0.95, // Độ trong suốt (Glass)
            thickness: 1.5,
            ior: 1.5, // Chỉ số khúc xạ
            iridescence: 1.0, // Hiệu ứng xà phòng
            clearcoat: 1.0
        });
        const glassSphere = new THREE.Mesh(glassGeo, glassMat);
        scene.add(glassSphere);

        // --- NÂNG CẤP: Thêm các vòng nhẫn xoay quanh (Gyroscope effect) ---
        const rings = [];
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xff0080, wireframe: true, transparent: true, opacity: 0.5 });
        for (let i = 0; i < 3; i++) {
            const ringGeo = new THREE.TorusGeometry(16 + (i * 4), 0.2, 16, 100);
            const ring = new THREE.Mesh(ringGeo, ringMat);
            rings.push(ring);
            scene.add(ring);
        }

        // --- NÂNG CẤP: Shader Material Object (Quả cầu biến dạng) ---
        // Sử dụng GLSL Shader tùy chỉnh để tạo hiệu ứng sóng biến dạng phức tạp
        const blobGeo = new THREE.IcosahedronGeometry(25, 6); // Tăng detail lên 6
        const blobMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0xaa00ff) }
            },
            vertexShader: `
                uniform float uTime;
                varying vec3 vNormal;
                void main() {
                    vNormal = normal;
                    vec3 pos = position;
                    // Biến dạng đỉnh dựa trên sóng sin/cos đa chiều
                    float distortion = sin(pos.x * 0.1 + uTime) * cos(pos.y * 0.1 + uTime) * sin(pos.z * 0.1 + uTime);
                    pos += normal * distortion * 5.0;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                varying vec3 vNormal;
                void main() {
                    // Hiệu ứng phát sáng cạnh (Fresnel-like)
                    float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                    gl_FragColor = vec4(uColor * intensity + vec3(0.0, 0.1, 0.2), 0.3);
                }
            `,
            wireframe: true,
            transparent: true,
            side: THREE.DoubleSide
        });
        const blob = new THREE.Mesh(blobGeo, blobMat);
        scene.add(blob);

        // --- NÂNG CẤP: Thêm các khối tinh thể trôi nổi ---
        const crystals = [];
        const crystalGeo = new THREE.OctahedronGeometry(1);
        const crystalMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5, flatShading: true });
        for (let i = 0; i < 30; i++) {
            const crystal = new THREE.Mesh(crystalGeo, crystalMat);
            crystal.position.set((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80);
            crystals.push({ mesh: crystal, speed: Math.random() * 0.02 + 0.01, offset: Math.random() * 100 });
            scene.add(crystal);
        }

        // --- NÂNG CẤP: Debris Field (Mảnh vỡ không gian - InstancedMesh) ---
        // Tạo hàng ngàn khối lập phương nhỏ xoay quanh (Siêu nặng cho CPU/GPU)
        const debrisCount = 2000; // Mặc định Low (2000)
        const debrisGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const debrisMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.4, metalness: 0.6 });
        const debrisMesh = new THREE.InstancedMesh(debrisGeo, debrisMat, debrisCount);
        debrisMesh.castShadow = true;
        debrisMesh.receiveShadow = true;
        
        const dummy = new THREE.Object3D();
        const debrisData = []; // Lưu dữ liệu để animate từng mảnh

        for (let i = 0; i < debrisCount; i++) {
            dummy.position.set((Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150);
            dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            dummy.updateMatrix();
            debrisMesh.setMatrixAt(i, dummy.matrix);
            debrisData.push({ 
                rotSpeed: (Math.random() - 0.5) * 0.05, 
                initialPos: dummy.position.clone(),
                offset: Math.random() * 100,
                velocity: new THREE.Vector3(), // Vận tốc vật lý
                physicsPos: new THREE.Vector3() // Vị trí vật lý tích lũy
            });
        }
        scene.add(debrisMesh);

        // --- NÂNG CẤP: Vortex (Cơn lốc Tetrahedrons) ---
        const vortexCount = 1000; // Mặc định Low (1000)
        const vortexGeo = new THREE.TetrahedronGeometry(0.5);
        const vortexMat = new THREE.MeshStandardMaterial({ color: 0xff00ff, roughness: 0.2, metalness: 0.8 });
        const vortexMesh = new THREE.InstancedMesh(vortexGeo, vortexMat, vortexCount);
        vortexMesh.castShadow = true;
        vortexMesh.receiveShadow = true;

        const vortexDummy = new THREE.Object3D();
        const vortexData = [];
        for(let i=0; i<vortexCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 50;
            const y = (Math.random() - 0.5) * 60;
            vortexData.push({ angle, radius, y, speed: 0.01 + Math.random() * 0.02 });
            vortexDummy.position.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
            vortexDummy.updateMatrix();
            vortexMesh.setMatrixAt(i, vortexDummy.matrix);
        }
        scene.add(vortexMesh);

        // --- NÂNG CẤP: Cyber Floor (Sàn nhà chuyển động) ---
        const floorSize = 20;
        const floorCount = floorSize * floorSize;
        const floorGeo = new THREE.BoxGeometry(4, 10, 4);
        floorGeo.translate(0, 5, 0); // Đặt tâm xoay xuống đáy
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9, roughness: 0.1 });
        const floorMesh = new THREE.InstancedMesh(floorGeo, floorMat, floorCount);
        floorMesh.receiveShadow = true;
        floorMesh.position.y = -50;
        
        const floorDummy = new THREE.Object3D();
        for(let i=0; i<floorSize; i++) {
            for(let j=0; j<floorSize; j++) {
                const index = i * floorSize + j;
                floorDummy.position.set((i - floorSize/2) * 5, 0, (j - floorSize/2) * 5);
                floorDummy.updateMatrix();
                floorMesh.setMatrixAt(index, floorDummy.matrix);
            }
        }
        scene.add(floorMesh);

        // --- NÂNG CẤP: Satellites (Vệ tinh nhân tạo) ---
        const satellites = [];
        const satGeoCore = new THREE.DodecahedronGeometry(1);
        const satGeoPanel = new THREE.BoxGeometry(0.2, 3, 6);
        const satMat = new THREE.MeshStandardMaterial({ color: 0x00aaff, metalness: 1, roughness: 0.2 });

        for(let i=0; i<6; i++) {
            const satGroup = new THREE.Group();
            const core = new THREE.Mesh(satGeoCore, satMat);
            const panel1 = new THREE.Mesh(satGeoPanel, satMat);
            panel1.position.x = -2;
            const panel2 = new THREE.Mesh(satGeoPanel, satMat);
            panel2.position.x = 2;
            satGroup.add(core, panel1, panel2);
            satGroup.castShadow = true;
            
            satGroup.userData = {
                angle: Math.random() * Math.PI * 2,
                radius: 40 + Math.random() * 20,
                speed: 0.005 + Math.random() * 0.01,
                yOffset: (Math.random() - 0.5) * 20
            };
            scene.add(satGroup);
            satellites.push(satGroup);
        }

        // --- NÂNG CẤP: Data Streams (4 chuỗi xoắn DNA khổng lồ) ---
        const streamCount = 4000;
        const streamGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const streamMat = new THREE.MeshBasicMaterial({ color: 0x00ffaa, wireframe: false });
        const streamMesh = new THREE.InstancedMesh(streamGeo, streamMat, streamCount);
        
        const streamDummy = new THREE.Object3D();
        const streamData = [];
        
        for(let i=0; i<streamCount; i++) {
            // Chia thành 4 nhánh
            const branch = i % 4;
            const t = Math.random() * 100; // Độ cao
            const angle = t * 0.5 + (branch * (Math.PI / 2));
            const radius = 60;
            
            streamDummy.position.set(Math.cos(angle) * radius, (t - 50) * 2, Math.sin(angle) * radius);
            streamDummy.updateMatrix();
            streamMesh.setMatrixAt(i, streamDummy.matrix);
            
            streamData.push({ branch, t, speed: 0.1 + Math.random() * 0.1, radius });
        }
        scene.add(streamMesh);

        // --- NÂNG CẤP: Dyson Sphere Cage (Lồng bao quanh vũ trụ) ---
        const cageGeo = new THREE.IcosahedronGeometry(200, 2);
        const cageMat = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: true, transparent: true, opacity: 0.3 });
        const cageMesh = new THREE.Mesh(cageGeo, cageMat);
        scene.add(cageMesh);

        // Lớp lồng thứ 2 nhỏ hơn, xoay ngược chiều
        const cageGeo2 = new THREE.IcosahedronGeometry(180, 1);
        const cageMat2 = new THREE.MeshBasicMaterial({ color: 0x666666, wireframe: true, transparent: true, opacity: 0.2 });
        const cageMesh2 = new THREE.Mesh(cageGeo2, cageMat2);
        scene.add(cageMesh2);

        // --- NÂNG CẤP: Hyperspace Tunnel (Đường hầm siêu không gian) ---
        const tunnelGeo = new THREE.CylinderGeometry(100, 100, 1000, 32, 5, true);
        const tunnelMat = new THREE.MeshBasicMaterial({ 
            color: 0x001133, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.15,
            side: THREE.DoubleSide
        });
        const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
        tunnel.rotation.x = Math.PI / 2;
        scene.add(tunnel);

        // --- NÂNG CẤP: Volumetric Fog (Sương mù thể tích di chuyển) ---
        const fogGeo = new THREE.BoxGeometry(300, 300, 300);
        const fogMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0x001133) } // Màu xanh đen bí ẩn
            },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec3 vPosition;

                // Hàm noise đơn giản từ sin/cos để tạo đám mây
                float getNoise(vec3 p) {
                    return sin(p.x * 0.05 + uTime * 0.5) * sin(p.y * 0.05 + uTime * 0.3) * sin(p.z * 0.05 + uTime * 0.2);
                }

                void main() {
                    float n = getNoise(vPosition);
                    // Tạo các mảng sương mù trôi nổi, mờ ảo
                    float alpha = smoothstep(0.0, 0.8, n) * 0.05; // Giảm độ đặc của sương mù
                    
                    // Làm mờ dần ở các cạnh xa để không thấy khung hộp
                    float dist = length(vPosition);
                    alpha *= smoothstep(150.0, 50.0, dist);

                    gl_FragColor = vec4(uColor + vec3(n * 0.1), alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const fogMesh = new THREE.Mesh(fogGeo, fogMat);
        scene.add(fogMesh);

        // --- NÂNG CẤP: Menger Sponge Fractal (Cấu trúc phân hình) ---
        // Tạo một khối fractal phức tạp bằng InstancedMesh
        const spongeCount = 8000; // Level 3: 20^3 = 8000 khối
        const spongeGeo = new THREE.BoxGeometry(1, 1, 1);
        const spongeMat = new THREE.MeshStandardMaterial({ 
            color: 0xcc3333, 
            roughness: 0.3, 
            metalness: 0.8 
        });
        const spongeMesh = new THREE.InstancedMesh(spongeGeo, spongeMat, spongeCount);
        spongeMesh.castShadow = true;
        spongeMesh.receiveShadow = true;

        const spongeDummy = new THREE.Object3D();
        let spongeIdx = 0;

        function generateMenger(x, y, z, size, level) {
            if (level === 0) {
                spongeDummy.position.set(x, y, z);
                spongeDummy.scale.set(size, size, size);
                spongeDummy.updateMatrix();
                if (spongeIdx < spongeCount) spongeMesh.setMatrixAt(spongeIdx++, spongeDummy.matrix);
                return;
            }
            const newSize = size / 3;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        let zeros = 0;
                        if (dx === 0) zeros++;
                        if (dy === 0) zeros++;
                        if (dz === 0) zeros++;
                        if (zeros < 2) {
                            generateMenger(x + dx * newSize, y + dy * newSize, z + dz * newSize, newSize, level - 1);
                        }
                    }
                }
            }
        }
        generateMenger(0, 0, 0, 180, 3); // Tạo fractal kích thước 180
        scene.add(spongeMesh);

        // --- NÂNG CẤP: Neural Network Lines (Các đường kết nối debris) ---
        const lineCount = 500;
        const lineGeo = new THREE.BufferGeometry();
        const linePos = new Float32Array(lineCount * 2 * 3); // 2 points per line, 3 coords per point
        lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
        const lineMesh = new THREE.LineSegments(lineGeo, lineMat);
        scene.add(lineMesh);

        // --- NÂNG CẤP: Titan Structure (Cấu trúc siêu nặng High-Poly) ---
        // Geometry cực kỳ chi tiết với hàng trăm ngàn tam giác
        const titanGeo = new THREE.TorusKnotGeometry(60, 2, 200, 32, 2, 5); // Mặc định Low Poly
        const titanMat = new THREE.MeshStandardMaterial({
            color: 0xffd700, // Vàng kim loại
            metalness: 1.0,
            roughness: 0.2,
            wireframe: true, // Wireframe để thấy độ dày đặc của lưới
            transparent: true,
            opacity: 0.15
        });
        const titanMesh = new THREE.Mesh(titanGeo, titanMat);
        scene.add(titanMesh);

        // --- NÂNG CẤP: Nano Swarm (Bầy đàn Nano - 10,000 vật thể động) ---
        const swarmCount = 2000; // Mặc định Low (2000)
        const swarmGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const swarmMat = new THREE.MeshPhysicalMaterial({
            color: 0x00ffff,
            metalness: 0.9,
            roughness: 0.1,
            clearcoat: 1.0
        });
        const swarmMesh = new THREE.InstancedMesh(swarmGeo, swarmMat, swarmCount);
        swarmMesh.castShadow = true;
        swarmMesh.receiveShadow = true;
        
        const swarmDummy = new THREE.Object3D();
        const swarmData = [];
        for(let i=0; i<swarmCount; i++) {
            swarmData.push({
                x: (Math.random() - 0.5) * 300,
                z: (Math.random() - 0.5) * 300,
                speed: Math.random() * 0.02 + 0.01,
                offset: Math.random() * 100
            });
        }
        scene.add(swarmMesh);

        // --- NÂNG CẤP: Volumetric Light Beams (Luồng sáng thể tích vật lý) ---
        // Tạo các hình nón ánh sáng xoay quanh lõi
        const beamGeo = new THREE.CylinderGeometry(2, 30, 200, 32, 1, true);
        const beamMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0x4488ff) }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                void main() {
                    float alpha = smoothstep(0.0, 0.2, vUv.y) * smoothstep(1.0, 0.5, vUv.y); // Fade 2 đầu
                    float noise = sin(vUv.x * 20.0 + uTime * 5.0) * 0.5 + 0.5; // Hiệu ứng sóng ánh sáng
                    alpha *= (0.3 + noise * 0.7);
                    gl_FragColor = vec4(uColor, alpha * 0.15);
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const beamMesh = new THREE.Mesh(beamGeo, beamMat);
        beamMesh.rotation.x = Math.PI / 2;
        scene.add(beamMesh);

        const beamMesh2 = beamMesh.clone();
        beamMesh2.rotation.x = Math.PI / 2;
        beamMesh2.rotation.z = Math.PI / 2;
        scene.add(beamMesh2);

        // 5. Tạo hệ thống hạt (Particles/Stars)
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 10000; // Mặc định Low (10000)
        const posArray = new Float32Array(particlesCount * 3);

        for(let i = 0; i < particlesCount * 3; i++) {
            // Tạo vị trí ngẫu nhiên trong không gian rộng
            posArray[i] = (Math.random() - 0.5) * 200; 
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.2,
            color: 0xffffff,
            transparent: true,
            opacity: 0.8,
        });
        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        // 6. Ánh sáng (Lighting)
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);

        // Texture cho Lensflare
        const textureLoader = new THREE.TextureLoader();
        const textureFlare0 = textureLoader.load('https://unpkg.com/three@0.160.0/examples/textures/lensflare/lensflare0.png');
        const textureFlare3 = textureLoader.load('https://unpkg.com/three@0.160.0/examples/textures/lensflare/lensflare3.png');

        function addLensflare(light) {
            const lensflare = new Lensflare();
            lensflare.addElement(new LensflareElement(textureFlare0, 600, 0, light.color));
            lensflare.addElement(new LensflareElement(textureFlare3, 60, 0.6));
            lensflare.addElement(new LensflareElement(textureFlare3, 70, 0.7));
            lensflare.addElement(new LensflareElement(textureFlare3, 120, 0.9));
            lensflare.addElement(new LensflareElement(textureFlare3, 70, 1));
            light.add(lensflare);
        }

        const pointLight1 = new THREE.PointLight(0xff0040, 200); // Giảm cường độ đèn
        pointLight1.position.set(20, 20, 20);
        pointLight1.castShadow = true;
        pointLight1.shadow.mapSize.width = 512; // Mặc định Low (512)
        pointLight1.shadow.mapSize.height = 512;
        addLensflare(pointLight1);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x0040ff, 200);
        pointLight2.position.set(-20, -20, 20);
        pointLight2.castShadow = true;
        pointLight2.shadow.mapSize.width = 512;
        pointLight2.shadow.mapSize.height = 512;
        addLensflare(pointLight2);
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight(0x80ff80, 200);
        pointLight3.position.set(0, 20, -20);
        pointLight3.castShadow = true;
        pointLight3.shadow.mapSize.width = 512;
        pointLight3.shadow.mapSize.height = 512;
        addLensflare(pointLight3);
        scene.add(pointLight3);

        // Helper để hiển thị vị trí đèn (tùy chọn, đã tắt để đẹp hơn)
        // const sphereSize = 1;
        // scene.add(new THREE.PointLightHelper(pointLight1, sphereSize));

        // Ẩn loading text khi đã sẵn sàng
        document.getElementById('loading').style.opacity = 0;

        // --- TÍNH NĂNG MỚI: Hyperdrive (Bước nhảy không gian) ---
        let isWarping = false;
        let warpFactor = 0; // 0: Bình thường, 1: Max tốc độ
        const warpBtn = document.getElementById('warp-btn');

        function toggleWarp() {
            isWarping = !isWarping;
            if(isWarping) warpBtn.classList.add('active');
            else warpBtn.classList.remove('active');
            sysLog(isWarping ? "WARP DRIVE: ENGAGED" : "WARP DRIVE: DISENGAGED");
        }

        warpBtn.addEventListener('click', toggleWarp);
        
        // Phím tắt Space để Supernova
        window.addEventListener('keydown', (e) => {
            if(e.code === 'Space') {
                triggerSupernova();
            }
        });

        // --- TÍNH NĂNG MỚI: Audio Reactivity (Phản ứng âm thanh) ---
        let audioContext, analyser, dataArray;
        let audioActive = false;
        const audioBtn = document.getElementById('audio-btn');

        async function setupAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                audioActive = true;
                audioBtn.classList.add('active');
                audioBtn.innerText = "MIC ACTIVE";
                sysLog("Audio Input: Connected");
            } catch (err) {
                console.error('Audio permission denied', err);
                alert("Cần quyền truy cập Microphone để kích hoạt tính năng này!");
            }
        }

        audioBtn.addEventListener('click', setupAudio);

        // --- TÍNH NĂNG MỚI: Gravity Control (Điều khiển trọng lực) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const gravityPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Mặt phẳng ảo để chiếu chuột
        const gravityTarget = new THREE.Vector3();
        let isGravityActive = 0; // 0: Tắt, 1: Hút, -1: Đẩy

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('mousedown', (event) => {
            if (event.button === 0) isGravityActive = 1; // Chuột trái: Hút
            if (event.button === 2) isGravityActive = -1; // Chuột phải: Đẩy
        });

        // --- TÍNH NĂNG MỚI: Shockwave (Sóng xung kích) ---
        const shockwaveGeo = new THREE.RingGeometry(1, 2, 64);
        const shockwaveMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true, 
            opacity: 0, 
            side: THREE.DoubleSide, 
            blending: THREE.AdditiveBlending 
        });
        const shockwaveMesh = new THREE.Mesh(shockwaveGeo, shockwaveMat);
        shockwaveMesh.visible = false;
        scene.add(shockwaveMesh);

        let shockwaveActive = false;
        let shockwaveTimer = 0;

        function triggerShockwave() {
            // 1. Visual Effect
            shockwaveMesh.position.copy(gravityTarget);
            shockwaveMesh.visible = true;
            shockwaveActive = true;
            shockwaveTimer = 0;
            shockwaveMat.opacity = 1;
            shockwaveMesh.scale.setScalar(1);

            // 2. Physics Effect (Đẩy mạnh các mảnh vỡ)
            for (let i = 0; i < debrisData.length; i++) {
                const data = debrisData[i];
                const currentPos = data.initialPos.clone().add(data.physicsPos);
                const dist = gravityTarget.distanceTo(currentPos);
                
                if (dist < 50) { // Bán kính ảnh hưởng
                    const forceDir = new THREE.Vector3().subVectors(currentPos, gravityTarget).normalize();
                    const force = 5.0 / (1 + dist * 0.1); // Lực đẩy cực mạnh
                    data.velocity.add(forceDir.multiplyScalar(force));
                }
            }
        }

        window.addEventListener('mouseup', () => {
            if (isGravityActive === 1) { // Nếu đang hút mà thả ra -> Bùm!
                triggerShockwave();
            }
            isGravityActive = 0;
        });
        
        // Ngăn menu chuột phải hiện ra
        window.addEventListener('contextmenu', event => event.preventDefault());

        // --- TÍNH NĂNG MỚI: System Logger ---
        const logEl = document.getElementById('system-log');
        function sysLog(msg) {
            const div = document.createElement('div');
            div.className = 'log-entry';
            // Thêm timestamp
            const time = new Date().toLocaleTimeString('en-US', {hour12: false});
            div.innerText = `[${time}] ${msg.toUpperCase()}`;
            logEl.appendChild(div);
            // Giữ lại tối đa 8 dòng
            if(logEl.children.length > 8) logEl.removeChild(logEl.firstChild);
        }

        // Log khởi động
        setTimeout(() => sysLog("System initialized"), 100);
        setTimeout(() => sysLog("GPU: " + rendererInfo.split('Angle')[0].trim()), 500);
        setTimeout(() => sysLog("Quantum Core... Online"), 1000);

        // --- TÍNH NĂNG MỚI: Time Slider ---
        const timeSlider = document.getElementById('time-slider');
        let manualTimeScale = 1.0;
        timeSlider.addEventListener('input', (e) => {
            manualTimeScale = parseFloat(e.target.value);
        });

        // --- TÍNH NĂNG MỚI: Theme Switcher & Glitch Control ---
        const themes = {
            cyberpunk: {
                primary: 0x156289, // Blue
                fog: 0x050505,
                matrix: '#00ff00',
                lights: [0xff0040, 0x0040ff, 0x80ff80], // Pink, Blue, Green
                beam: 0x4488ff,
                blob: 0xaa00ff
            },
            matrix: {
                primary: 0x003300, // Dark Green
                fog: 0x001100,
                matrix: '#00ff00',
                lights: [0x00ff00, 0x008800, 0xccffcc], // All Green variants
                beam: 0x00ff00,
                blob: 0x00ff00
            },
            inferno: {
                primary: 0x330000, // Dark Red
                fog: 0x110000,
                matrix: '#ff0000',
                lights: [0xff0000, 0xff8800, 0xffaa00], // Red, Orange, Yellow
                beam: 0xff4400,
                blob: 0xff0000
            }
        };

        document.getElementById('theme-select').addEventListener('change', (e) => {
            const t = themes[e.target.value];
            if(!t) return;

            // Cập nhật màu sắc
            scene.fog.color.setHex(t.fog);
            matrixColor = t.matrix;
            
            // Vật thể chính
            torusKnot.material.color.setHex(t.primary);
            
            // Đèn
            pointLight1.color.setHex(t.lights[0]);
            pointLight2.color.setHex(t.lights[1]);
            pointLight3.color.setHex(t.lights[2]);

            // Shader materials
            fogMat.uniforms.uColor.value.setHex(t.fog); // Sương mù theo màu nền
            beamMat.uniforms.uColor.value.setHex(t.beam);
            blobMat.uniforms.uColor.value.setHex(t.blob);

            sysLog(`Theme changed to: ${e.target.value.toUpperCase()}`);
        });

        document.getElementById('glitch-btn').addEventListener('click', () => {
            glitchPass.enabled = !glitchPass.enabled;
            sysLog(glitchPass.enabled ? "SYSTEM FAILURE: GLITCH ACTIVE" : "SYSTEM STABILIZED");
        });

        // --- TÍNH NĂNG MỚI: Black Hole ---
        let isBlackHoleActive = false;
        const blackHoleBtn = document.getElementById('blackhole-btn');
        
        // Visual: Black Sphere
        const blackHoleGeo = new THREE.SphereGeometry(15, 32, 32);
        const blackHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackHoleMesh = new THREE.Mesh(blackHoleGeo, blackHoleMat);
        blackHoleMesh.visible = false;
        scene.add(blackHoleMesh);

        // Visual: Accretion Disk (Ring)
        const diskGeo = new THREE.RingGeometry(18, 40, 64);
        const diskMat = new THREE.MeshBasicMaterial({ 
            color: 0xff4400, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.5,
            blending: THREE.AdditiveBlending
        });
        const accretionDisk = new THREE.Mesh(diskGeo, diskMat);
        accretionDisk.rotation.x = Math.PI / 2;
        accretionDisk.visible = false;
        scene.add(accretionDisk);

        blackHoleBtn.addEventListener('click', () => {
            isBlackHoleActive = !isBlackHoleActive;
            if(isBlackHoleActive) {
                blackHoleBtn.classList.add('active');
                blackHoleBtn.innerText = "BLACK HOLE: ACTIVE";
                blackHoleMesh.visible = true;
                accretionDisk.visible = true;
                quantumCore.visible = false;
                sysLog("WARNING: SINGULARITY DETECTED");
            } else {
                blackHoleBtn.classList.remove('active');
                blackHoleBtn.innerText = "ACTIVATE BLACK HOLE";
                blackHoleMesh.visible = false;
                accretionDisk.visible = false;
                quantumCore.visible = true;
                sysLog("Singularity Collapsed");
            }
        });

        // --- TÍNH NĂNG MỚI: Supernova ---
        const supernovaBtn = document.getElementById('supernova-btn');
        
        // Visual: Expanding Star Core
        const supernovaGeo = new THREE.SphereGeometry(1, 32, 32);
        const supernovaMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0 });
        const supernovaMesh = new THREE.Mesh(supernovaGeo, supernovaMat);
        scene.add(supernovaMesh);

        let supernovaActive = false;
        let supernovaTime = 0;

        function triggerSupernova() {
            if(supernovaActive) return;
            supernovaActive = true;
            supernovaTime = 0;
            supernovaMesh.visible = true;
            supernovaMat.opacity = 1;
            supernovaMesh.scale.setScalar(1);
            
            sysLog("WARNING: SUPERNOVA DETECTED");
            
            // Physics push (Đẩy cực mạnh mọi vật thể ra xa)
             for (let i = 0; i < debrisCount; i++) {
                const data = debrisData[i];
                const currentPos = data.initialPos.clone().add(data.physicsPos);
                const dist = currentPos.length();
                
                const forceDir = currentPos.normalize();
                const force = 1000.0 / (1 + dist * 0.05); // Lực nổ cực lớn
                data.velocity.add(forceDir.multiplyScalar(force));
            }
        }

        supernovaBtn.addEventListener('click', triggerSupernova);

        // --- TÍNH NĂNG MỚI: Scanner Logic ---
        const scanBtn = document.getElementById('scan-btn');
        let isScanning = false;
        let scanTime = 0;

        scanBtn.addEventListener('click', () => {
            if(isScanning) return;
            isScanning = true;
            scanTime = 0;
            scannerPass.enabled = true;
            sysLog("INITIATING SYSTEM SCAN...");
        });

        // --- TÍNH NĂNG MỚI: Digital Rain on Objects ---
        const rainBtn = document.getElementById('rain-btn');
        let isRainActive = false;
        
        const MatrixObjectShader = {
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0x00ff00) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec2 vUv;
                
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    float rows = 30.0; // Mật độ dòng
                    vec2 ipos = floor(vUv * rows);
                    
                    // Tốc độ rơi ngẫu nhiên cho mỗi cột
                    float speed = 5.0 + random(vec2(ipos.x, 0.0)) * 5.0;
                    float y = floor(vUv.y * rows + uTime * speed);
                    
                    // Ký tự ngẫu nhiên (giả lập bằng noise)
                    float char = step(0.5, random(vec2(ipos.x, y)));
                    
                    // Hiệu ứng mờ dần (Trail)
                    float trail = fract(vUv.y * 5.0 + uTime * speed * 0.2);
                    trail = pow(trail, 3.0);

                    vec3 finalColor = uColor * char * trail;
                    float alpha = length(finalColor);
                    
                    gl_FragColor = vec4(finalColor, alpha * 0.9);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        };

        const matrixObjMat = new THREE.ShaderMaterial(MatrixObjectShader);
        const originalTorusMat = torusKnot.material;
        const originalTitanMat = titanMesh.material;
        const originalDebrisMat = debrisMesh.material;

        rainBtn.addEventListener('click', () => {
            isRainActive = !isRainActive;
            if(isRainActive) {
                torusKnot.material = matrixObjMat;
                titanMesh.material = matrixObjMat;
                debrisMesh.material = matrixObjMat;
                rainBtn.classList.add('active');
                rainBtn.innerText = "DIGITAL RAIN: ON";
                sysLog("MATRIX CAMOUFLAGE: ACTIVE");
            } else {
                torusKnot.material = originalTorusMat;
                titanMesh.material = originalTitanMat;
                debrisMesh.material = originalDebrisMat;
                rainBtn.classList.remove('active');
                rainBtn.innerText = "DIGITAL RAIN";
                sysLog("MATRIX CAMOUFLAGE: DISABLED");
            }
        });

        // --- TÍNH NĂNG MỚI: Wireframe Mode ---
        const wireframeBtn = document.getElementById('wireframe-btn');
        let isWireframe = false;

        wireframeBtn.addEventListener('click', () => {
            isWireframe = !isWireframe;
            
            if (isWireframe) {
                wireframeBtn.classList.add('active');
                wireframeBtn.innerText = "WIREFRAME: ON";
                sysLog("VISUAL SYSTEM: WIREFRAME MODE ENGAGED");

                scene.traverse((obj) => {
                    if (obj.isMesh && obj !== particlesMesh) {
                        // Lưu material gốc
                        if (!obj.userData.originalMat) {
                            obj.userData.originalMat = obj.material;
                        }
                        
                        // Lấy màu gốc hoặc dùng màu mặc định
                        let color = 0x00ff00;
                        if (obj.material.color) color = obj.material.color;
                        else if (obj.material.uniforms && obj.material.uniforms.uColor) color = obj.material.uniforms.uColor.value;

                        obj.material = new THREE.MeshBasicMaterial({
                            color: color,
                            wireframe: true,
                            transparent: true,
                            opacity: 0.8
                        });
                    }
                });
                scene.fog.density = 0; // Tắt sương mù
            } else {
                wireframeBtn.classList.remove('active');
                wireframeBtn.innerText = "WIREFRAME MODE";
                sysLog("VISUAL SYSTEM: STANDARD MODE RESTORED");

                scene.traverse((obj) => {
                    if (obj.isMesh && obj.userData.originalMat) {
                        obj.material = obj.userData.originalMat;
                    }
                });
                scene.fog.density = 0.002; // Khôi phục sương mù
            }
        });

        // --- TÍNH NĂNG MỚI: Energy Pulse (Audio Reactive) ---
        const pulseGroup = new THREE.Group();
        scene.add(pulseGroup);
        const audioPulses = [];
        let lastPulseTime = 0;
        const pulseCooldown = 200; // ms, thời gian chờ giữa các xung

        function spawnAudioPulse(color) {
            const pulseGeo = new THREE.RingGeometry(1, 1.5, 64);
            const pulseMat = new THREE.MeshBasicMaterial({
                color: color || 0x00ffff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const pulseMesh = new THREE.Mesh(pulseGeo, pulseMat);
            audioPulses.push({
                mesh: pulseMesh,
                startTime: Date.now()
            });
            pulseGroup.add(pulseMesh);
        }

        // --- TÍNH NĂNG MỚI: Landing & CPU Test Logic ---
        window.startBenchmarkMode = function() {
            document.getElementById('landing-screen').style.display = 'none';
            // Hiện các UI game
            document.querySelectorAll('.game-ui').forEach(el => el.classList.remove('game-ui'));
            // Hiện Stats
            stats.dom.style.display = 'block';
            statsMem.dom.style.display = 'block';
            document.getElementById('gpu-info').style.display = 'block';
            
            // --- AUTO DETECT HARDWARE QUALITY (Tự động chọn cấu hình) ---
            let autoLevel = 1; // Mặc định Low
            const gpu = rendererInfo.toLowerCase();
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (isMobile) {
                // Mobile Logic
                if (gpu.includes('adreno 7') || gpu.includes('apple gpu') || gpu.includes('immortalis')) {
                    autoLevel = 2; // Medium (High-end Mobile)
                } else if (gpu.includes('adreno 6') || gpu.includes('mali-g7')) {
                    autoLevel = 1; // Low (Mid-range Mobile)
                } else {
                    autoLevel = 0; // Super Low (Budget/Old Mobile)
                }
            } else {
                // Desktop Logic
                if (gpu.includes('rtx 40') || gpu.includes('rx 79')) autoLevel = 5; // Extreme
                else if (gpu.includes('rtx 30') || gpu.includes('rx 6') || gpu.includes('rx 7')) autoLevel = 4; // Ultra
                else if (gpu.includes('rtx 20') || gpu.includes('gtx 108') || gpu.includes('apple m2') || gpu.includes('apple m3') || gpu.includes('apple m1 pro') || gpu.includes('apple m1 max')) autoLevel = 3; // High
                else if (gpu.includes('gtx 16') || gpu.includes('gtx 106') || gpu.includes('apple m1') || gpu.includes('radeon')) autoLevel = 2; // Medium
                else autoLevel = 1; // Low (Integrated/Old)
            }

            sysLog(`Hardware Detected: ${rendererInfo}`);
            sysLog(`Auto-Config: Level ${autoLevel} Selected`);
            window.setQuality(autoLevel);

            sysLog("Benchmark Mode: Engaged");
        };

        window.startCpuMode = function() {
            document.getElementById('landing-screen').style.display = 'none';
            document.getElementById('cpu-screen').style.display = 'flex';
            
            // Tạm dừng render 3D để dồn lực cho CPU
            renderer.setAnimationLoop(null);

            // --- Detect System Info ---
            const ua = navigator.userAgent;
            let os = "Unknown OS";
            if (ua.indexOf("Win") !== -1) os = "Windows";
            if (ua.indexOf("Mac") !== -1) os = "MacOS";
            if (ua.indexOf("X11") !== -1) os = "UNIX";
            if (ua.indexOf("Linux") !== -1) os = "Linux";
            if (ua.indexOf("Android") !== -1) os = "Android";
            if (ua.indexOf("like Mac") !== -1) os = "iOS";

            let browser = "Unknown Browser";
            if (ua.indexOf("Firefox") > -1) browser = "Mozilla Firefox";
            else if (ua.indexOf("SamsungBrowser") > -1) browser = "Samsung Internet";
            else if (ua.indexOf("Opera") > -1 || ua.indexOf("OPR") > -1) browser = "Opera";
            else if (ua.indexOf("Edge") > -1) browser = "Microsoft Edge";
            else if (ua.indexOf("Chrome") > -1) browser = "Google Chrome";
            else if (ua.indexOf("Safari") > -1) browser = "Apple Safari";

            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
            const deviceType = isMobile ? "Mobile Device" : "Desktop/Laptop";

            document.getElementById('cpu-system-info').innerHTML = `SYSTEM: ${os} | BROWSER: ${browser}<br>TYPE: ${deviceType}`;

            const threads = navigator.hardwareConcurrency || 4;
            const statusEl = document.getElementById('cpu-status');
            const progressEl = document.getElementById('cpu-progress');
            const resultsEl = document.getElementById('cpu-results');
            const canvas = document.getElementById('cpu-render-canvas');
            const ctx = canvas.getContext('2d');

            // --- Raytracer Worker Code ---
            const workerBlob = new Blob([`
                self.onmessage = function(e) {
                    const { startY, endY, width, height, id, time } = e.data;
                    const data = new Uint8ClampedArray(width * (endY - startY) * 4);
                    
                    // Scene definition
                    const t = time * 0.002;
                    const spheres = [
                        { c: {x: Math.sin(t)*1.5, y: -0.5, z: 3 + Math.cos(t)}, r: 0.5, col: {r: 255, g: 50, b: 50}, refl: 0.2 },
                        { c: {x: 1.2, y: -0.5 + Math.abs(Math.sin(t*2))*0.5, z: 3.5}, r: 0.5, col: {r: 50, g: 255, b: 50}, refl: 0.3 },
                        { c: {x: -1.2, y: -0.5, z: 3.5}, r: 0.5, col: {r: 50, g: 50, b: 255}, refl: 0.3 },
                        { c: {x: 0, y: -100.5, z: 3}, r: 100, col: {r: 200, g: 200, b: 200}, refl: 0.1 } // Floor
                    ];
                    const light = { x: 2, y: 2, z: 0 };

                    function dot(v1, v2) { return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z; }
                    function sub(v1, v2) { return {x: v1.x-v2.x, y: v1.y-v2.y, z: v1.z-v2.z}; }
                    function add(v1, v2) { return {x: v1.x+v2.x, y: v1.y+v2.y, z: v1.z+v2.z}; }
                    function mul(v, s) { return {x: v.x*s, y: v.y*s, z: v.z*s}; }
                    function normalize(v) { const len = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z); return {x: v.x/len, y: v.y/len, z: v.z/len}; }
                    
                    function intersect(ro, rd) {
                        let t = Infinity;
                        let obj = null;
                        for(let s of spheres) {
                            const oc = sub(ro, s.c);
                            const b = dot(oc, rd);
                            const c = dot(oc, oc) - s.r*s.r;
                            const d = b*b - c;
                            if(d > 0) {
                                const temp = -b - Math.sqrt(d);
                                if(temp > 0.001 && temp < t) { t = temp; obj = s; }
                            }
                        }
                        return {t, obj};
                    }

                    function trace(ro, rd, depth) {
                        let col = {r: 0, g: 0, b: 0};
                        const hit = intersect(ro, rd);
                        if(hit.obj) {
                            const p = add(ro, mul(rd, hit.t));
                            const n = normalize(sub(p, hit.obj.c));
                            const l = normalize(sub(light, p));
                            const diff = Math.max(0, dot(n, l));
                            
                            // Shadow
                            const shadowHit = intersect(add(p, mul(n, 0.001)), l);
                            const shadow = (shadowHit.obj) ? 0.5 : 1.0;

                            col.r = hit.obj.col.r * diff * shadow;
                            col.g = hit.obj.col.g * diff * shadow;
                            col.b = hit.obj.col.b * diff * shadow;

                            if(depth > 0 && hit.obj.refl > 0) {
                                const reflDir = sub(rd, mul(n, 2 * dot(rd, n)));
                                const reflCol = trace(add(p, mul(n, 0.001)), normalize(reflDir), depth - 1);
                                col.r = col.r * (1-hit.obj.refl) + reflCol.r * hit.obj.refl;
                                col.g = col.g * (1-hit.obj.refl) + reflCol.g * hit.obj.refl;
                                col.b = col.b * (1-hit.obj.refl) + reflCol.b * hit.obj.refl;
                            }
                        } else {
                            // Sky gradient
                            const t = 0.5 * (rd.y + 1.0);
                            col.r = (1-t)*255 + t*100;
                            col.g = (1-t)*255 + t*150;
                            col.b = (1-t)*255 + t*255;
                        }
                        return col;
                    }

                    let idx = 0;
                    for(let y = startY; y < endY; y++) {
                        for(let x = 0; x < width; x++) {
                            // Camera setup
                            const uv = { x: (x / width) * 2 - 1, y: -(y / height) * 2 + 1 };
                            uv.x *= width / height;
                            const ro = {x: 0, y: 0, z: 0};
                            const rd = normalize({x: uv.x, y: uv.y, z: 1});
                            
                            const col = trace(ro, rd, 2); // Max depth 2
                            
                            data[idx++] = col.r;
                            data[idx++] = col.g;
                            data[idx++] = col.b;
                            data[idx++] = 255;
                        }
                    }
                    self.postMessage({ id, startY, endY, buffer: data.buffer }, [data.buffer]);
                };
            `], { type: 'text/javascript' });
            const workerUrl = URL.createObjectURL(workerBlob);

            function runRenderTask(threadCount, time) {
                const width = canvas.width;
                const height = canvas.height;
                return new Promise(resolve => {
                    ctx.clearRect(0, 0, width, height);
                    const startTime = performance.now();
                    let completed = 0;
                    const workers = [];
                    const chunkHeight = Math.ceil(height / threadCount);

                    for(let i=0; i<threadCount; i++) {
                        const worker = new Worker(workerUrl);
                        workers.push(worker);
                        const startY = i * chunkHeight;
                        const endY = Math.min((i + 1) * chunkHeight, height);
                        
                        worker.postMessage({ startY, endY, width, height, id: i, time });
                        
                        worker.onmessage = function(e) {
                            const { startY, endY, buffer } = e.data;
                            const imgData = new ImageData(new Uint8ClampedArray(buffer), width, endY - startY);
                            ctx.putImageData(imgData, 0, startY);
                            
                            completed++;
                            worker.terminate();
                            
                            // Progress bar handled by main loop now

                            if(completed === threadCount) {
                                resolve(performance.now() - startTime);
                            }
                        };
                    }
                });
            }

            async function runBenchmark() {
                document.getElementById('cpu-start-btn').disabled = true;
                document.getElementById('cpu-res-select').disabled = true;
                document.getElementById('cpu-start-btn').innerText = "RUNNING...";
                
                const frameCount = 10; // Render 10 frames for animation test
                const width = canvas.width;
                const height = canvas.height;
                const totalPixels = width * height;

                // 1. Single Core Test
                let totalTimeSingle = 0;
                for(let i=0; i<frameCount; i++) {
                    statusEl.innerText = `SINGLE-CORE: RENDERING FRAME ${i+1}/${frameCount}`;
                    progressEl.style.width = `${((i+1)/frameCount)*100}%`;
                    const t = await runRenderTask(1, i * 200);
                    totalTimeSingle += t;
                }
                const avgTimeSingle = totalTimeSingle / frameCount;
                // Score = Pixels per Second / 100
                const scoreSingle = Math.floor((totalPixels / avgTimeSingle) * 1000 / 100);
                
                document.querySelector('#score-single .val').innerText = scoreSingle;
                document.querySelector('#score-single .val').style.color = '#00ff00';

                await new Promise(r => setTimeout(r, 1000)); // Pause

                // 2. Multi Core Test
                let totalTimeMulti = 0;
                for(let i=0; i<frameCount; i++) {
                    statusEl.innerText = `MULTI-CORE (${threads} THREADS): RENDERING FRAME ${i+1}/${frameCount}`;
                    progressEl.style.width = `${((i+1)/frameCount)*100}%`;
                    const t = await runRenderTask(threads, i * 200);
                    totalTimeMulti += t;
                }
                const avgTimeMulti = totalTimeMulti / frameCount;
                const scoreMulti = Math.floor((totalPixels / avgTimeMulti) * 1000 / 100);
                
                document.querySelector('#score-multi .val').innerText = scoreMulti;
                document.querySelector('#score-multi .val').style.color = '#00ff00';

                // Finish
                statusEl.innerText = "BENCHMARK COMPLETE";
                statusEl.style.color = "#00ff00";
                document.querySelector('.cpu-bar-fill').style.background = "#00ff00";
                document.querySelector('.cpu-bar-bg').style.borderColor = "#00ff00";

                // Real World Leaderboard Data (Estimated JS Raytracing Scores)
                const leaderboardData = [
                    { name: "Desktop (Core i9-14900K)", score: 28500 },
                    { name: "MacBook Pro (M3 Max)", score: 26000 },
                    { name: "Desktop (Ryzen 9 7950X)", score: 25500 },
                    { name: "iPhone 15 Pro (A17 Pro)", score: 18500 },
                    { name: "Gaming Laptop (i7-13700H)", score: 16000 },
                    { name: "Android Flagship (SD 8 Gen 3)", score: 14500 },
                    { name: "MacBook Air (M2)", score: 11000 },
                    { name: "Mid-Range PC (i5-12400)", score: 9500 },
                    { name: "Budget Laptop (Ryzen 5)", score: 6500 },
                    { name: "Budget Phone (Snapdragon 695)", score: 2500 },
                    { name: "Old Laptop (Celeron)", score: 800 }
                ];
                
                leaderboardData.push({ name: "YOUR DEVICE", score: scoreMulti, isUser: true });
                leaderboardData.sort((a, b) => b.score - a.score);
                
                let lbHtml = `
                    <div class="leaderboard">
                        <div class="leaderboard-header">
                            <div class="leaderboard-rank">#</div>
                            <div class="leaderboard-name">DEVICE</div>
                            <div class="leaderboard-score">SCORE</div>
                        </div>
                `;
                
                leaderboardData.forEach((item, index) => {
                    const rank = index + 1;
                    const userClass = item.isUser ? 'user' : '';
                    lbHtml += `
                        <div class="leaderboard-item ${userClass}">
                            <div class="leaderboard-rank">${rank}</div>
                            <div class="leaderboard-name">${item.name}</div>
                            <div class="leaderboard-score">${item.score.toLocaleString()}</div>
                        </div>
                    `;
                });
                lbHtml += '</div>';

                resultsEl.innerHTML = `
                    Avg Frame Time: ${(avgTimeSingle).toFixed(1)}ms (Single) / ${(avgTimeMulti).toFixed(1)}ms (Multi)<br>
                    Threads Used: ${threads}
                    ${lbHtml}
                `;

                // --- Draw Comparison Chart (Vẽ biểu đồ so sánh) ---
                const chartCanvas = document.getElementById('cpu-chart-canvas');
                chartCanvas.style.display = 'block';
                const ctxChart = chartCanvas.getContext('2d');
                const cw = chartCanvas.width;
                const ch = chartCanvas.height;
                
                ctxChart.clearRect(0, 0, cw, ch);
                
                // Tiêu đề biểu đồ
                ctxChart.fillStyle = '#fff';
                ctxChart.font = 'bold 16px monospace';
                ctxChart.textAlign = 'center';
                ctxChart.fillText('PERFORMANCE COMPARISON', cw/2, 30);
                
                const maxScore = leaderboardData[0].score;
                
                leaderboardData.forEach((item, i) => {
                    const y = 60 + i * 28;
                    if(y > ch - 20) return;

                    // Tên thiết bị
                    ctxChart.font = '12px monospace';
                    ctxChart.textAlign = 'right';
                    ctxChart.fillStyle = item.isUser ? '#00ff00' : '#888';
                    ctxChart.fillText(item.name, 200, y + 10);

                    // Thanh điểm số
                    const barWidth = (item.score / maxScore) * (cw - 280);
                    ctxChart.fillStyle = item.isUser ? '#00ff00' : '#333';
                    ctxChart.fillRect(210, y - 5, barWidth, 18);

                    // Số điểm
                    ctxChart.textAlign = 'left';
                    ctxChart.fillStyle = '#fff';
                    ctxChart.fillText(item.score.toLocaleString(), 210 + barWidth + 8, y + 10);
                });

                document.getElementById('cpu-start-btn').disabled = false;
                document.getElementById('cpu-res-select').disabled = false;
                document.getElementById('cpu-start-btn').innerText = "RE-RUN TEST";
            }

            const startBtn = document.getElementById('cpu-start-btn');
            startBtn.onclick = function() {
                const res = document.getElementById('cpu-res-select').value.split('x');
                canvas.width = parseInt(res[0]);
                canvas.height = parseInt(res[1]);
                runBenchmark();
            };
        };

        // --- TÍNH NĂNG MỚI: Auto Director (Đạo diễn tự động) ---
        let isDirectorMode = false;
        const directorBtn = document.getElementById('director-btn');
        let shotStartTime = 0;
        let shotDuration = 0;
        const camStartPos = new THREE.Vector3();
        const camEndPos = new THREE.Vector3();
        const camLookStart = new THREE.Vector3();
        const camLookEnd = new THREE.Vector3();

        function toggleDirector() {
            isDirectorMode = !isDirectorMode;
            controls.enabled = !isDirectorMode; // Tắt điều khiển tay khi bật Auto
            
            const barTop = document.getElementById('cinematic-bar-top');
            const barBottom = document.getElementById('cinematic-bar-bottom');
            
            if (isDirectorMode) {
                directorBtn.classList.add('active');
                directorBtn.innerText = "DIRECTOR: ON";
                // Bật Cinematic Bars (12% chiều cao mỗi dải)
                barTop.style.height = "12%";
                barBottom.style.height = "12%";
                pickNewShot();
            } else {
                directorBtn.classList.remove('active');
                directorBtn.innerText = "AUTO DIRECTOR";
                // Tắt Cinematic Bars
                barTop.style.height = "0";
                barBottom.style.height = "0";
                controls.target.set(0, 0, 0); // Reset target về tâm
            }
            sysLog(`Auto Director: ${isDirectorMode ? 'ON' : 'OFF'}`);
        }

        directorBtn.addEventListener('click', toggleDirector);

        function pickNewShot() {
            shotStartTime = Date.now() * 0.001;
            shotDuration = 4 + Math.random() * 6; // 4-10 giây mỗi cảnh

            // Random vị trí camera
            const r = Math.random();
            
            // Target ngẫu nhiên quanh tâm
            camLookStart.set((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
            camLookEnd.copy(camLookStart).addScalar((Math.random()-0.5)*5);

            if (r < 0.25) { // Cận cảnh (Close-up)
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 10;
                camStartPos.set(Math.cos(angle)*radius, (Math.random()-0.5)*5, Math.sin(angle)*radius);
                camEndPos.copy(camStartPos).add(new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2));
            } else if (r < 0.5) { // Toàn cảnh (Wide shot) xoay nhẹ
                const angle = Math.random() * Math.PI * 2;
                const radius = 60 + Math.random() * 30;
                const y = (Math.random()-0.5) * 40;
                camStartPos.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
                const angle2 = angle + 0.5; // Xoay một đoạn
                camEndPos.set(Math.cos(angle2)*radius, y, Math.sin(angle2)*radius);
            } else if (r < 0.75) { // Góc thấp/cao (Low/High angle)
                const angle = Math.random() * Math.PI * 2;
                const radius = 40 + Math.random() * 20;
                camStartPos.set(Math.cos(angle)*radius, (Math.random() > 0.5 ? 40 : -40), Math.sin(angle)*radius);
                camEndPos.set(Math.cos(angle)*radius*0.8, 0, Math.sin(angle)*radius*0.8); // Zoom vào
            } else { // Bay xuyên qua (Fly-through)
                camStartPos.set((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
                camEndPos.set((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
            }
        }

        function updateDirector() {
            const now = Date.now() * 0.001;
            const elapsed = now - shotStartTime;
            if (elapsed > shotDuration) { pickNewShot(); return; }
            const progress = elapsed / shotDuration;
            const smooth = progress * progress * (3 - 2 * progress); // Smoothstep
            camera.position.lerpVectors(camStartPos, camEndPos, smooth);
            const currentLook = new THREE.Vector3().lerpVectors(camLookStart, camLookEnd, smooth);
            camera.lookAt(currentLook);
        }

        // --- TÍNH NĂNG MỚI: Benchmark Mode (Chấm điểm hiệu năng) ---
        let isBenchmarking = false;
        let benchStartTime = 0;
        let benchFrames = 0;
        let benchFrameTimes = [];
        const benchmarkBtn = document.getElementById('benchmark-btn');

        benchmarkBtn.addEventListener('click', () => {
            if(isBenchmarking) return;
            isBenchmarking = true;
            benchFrames = 0;
            benchFrameTimes = [];
            benchStartTime = performance.now();
            
            // Tự động bật chế độ Director để camera di chuyển
            if(!isDirectorMode) toggleDirector();
            
            // Ẩn UI
            document.querySelector('.quality-controls').style.display = 'none';
            benchmarkBtn.innerText = "BENCHMARKING...";
            benchmarkBtn.style.color = "#ff0000";
            benchmarkBtn.style.borderColor = "#ff0000";
            sysLog("Starting Performance Analysis...");
        });

        function finishBenchmark(durationMs) {
            isBenchmarking = false;
            const avgFps = benchFrames / (durationMs / 1000);
            
            // Tính 1% Low FPS
            // Chuyển đổi frame time thành FPS và sắp xếp tăng dần
            const fpsValues = benchFrameTimes.map(t => t > 0 ? 1/t : 0).sort((a, b) => a - b);
            const index1Low = Math.floor(fpsValues.length * 0.01);
            const low1Percent = fpsValues[index1Low] || 0;

            // Công thức tính điểm: FPS * (Level^1.5) * 100
            // Level càng cao điểm càng được nhân nhiều
            const levelMultiplier = Math.pow((window.currentQualityLevel || 1) + 1, 1.5); 
            const score = Math.floor(avgFps * levelMultiplier * 50);

            // Hiển thị kết quả
            document.getElementById('benchmark-score').innerText = score;
            document.getElementById('benchmark-fps').innerHTML = `AVG FPS: ${avgFps.toFixed(1)} <span style="color:#ff0055; margin-left:10px;">1% LOW: ${low1Percent.toFixed(1)}</span> | Quality: LV${window.currentQualityLevel}`;
            document.getElementById('benchmark-modal').style.display = 'block';

            // Khôi phục UI
            document.querySelector('.quality-controls').style.display = 'flex';
            benchmarkBtn.innerText = "RUN BENCHMARK";
            benchmarkBtn.style.color = "#00ffff";
            benchmarkBtn.style.borderColor = "#00ffff";

            // Tắt Director mode
            if(isDirectorMode) toggleDirector();
            sysLog(`Benchmark Done. Score: ${score}`);
        }

        // --- TÍNH NĂNG MỚI: Hệ thống điều chỉnh chất lượng đồ họa (5 Cấp độ) ---
        window.currentQualityLevel = 1; // Mặc định

        window.setQuality = function(level) {
            // --- HYPERSPACE JUMP SEQUENCE ---
            sysLog("INITIATING HYPERSPACE JUMP...");
            isWarping = true; 
            if(warpBtn) warpBtn.classList.add('active');

            const overlay = document.getElementById('transition-overlay');
            
            // 1. Đợi Warp tăng tốc (800ms) rồi mới Fade Out
            setTimeout(() => {
                overlay.style.opacity = 1;

                // 2. Đợi màn hình đen rồi mới đổi cấu hình (500ms)
                setTimeout(() => {
                    window.currentQualityLevel = level;

                // Cập nhật UI
                document.querySelectorAll('.quality-btn').forEach((btn, idx) => {
                    // idx 0 là Super Low (level 0), idx 1 là Low (level 1)...
                    if (idx === level) btn.classList.add('active');
                    else btn.classList.remove('active');
                });

                // Cấu hình cho từng cấp độ
                const config = {
                    0: { debris: 200,  vortex: 100,  swarm: 200,   particles: 2000,  shadow: 0,    torus: [60, 8],     titan: [60, 8],     passes: [false, false, false, false, false] }, // Super Low
                    1: { debris: 2000, vortex: 1000, swarm: 2000, particles: 10000, shadow: 512,  torus: [300, 32],   titan: [200, 32],   passes: [false, false, false, false, false] }, // Low
                    2: { debris: 5000, vortex: 3000, swarm: 5000, particles: 20000, shadow: 1024, torus: [500, 64],   titan: [500, 64],   passes: [true, false, false, false, false] },  // Medium
                    3: { debris: 8000, vortex: 5000, swarm: 10000, particles: 40000, shadow: 2048, torus: [800, 100],  titan: [1000, 100], passes: [true, true, false, false, true] },   // High (+SSAO, +Dirt)
                    4: { debris: 10000, vortex: 7000, swarm: 15000, particles: 50000, shadow: 4096, torus: [1200, 150], titan: [2000, 200], passes: [true, true, true, false, true] },    // Ultra (+GodRays)
                    5: { debris: 12000, vortex: 8000, swarm: 20000, particles: 60000, shadow: 4096, torus: [1500, 200], titan: [2500, 400], passes: [true, true, true, true, true] }      // Extreme (+Sharpen)
                }[level];

                // 1. Cập nhật số lượng vật thể (InstancedMesh & Particles)
                debrisMesh.count = config.debris;
                vortexMesh.count = config.vortex;
                swarmMesh.count = config.swarm;
                particlesMesh.geometry.setDrawRange(0, config.particles);

                // 2. Cập nhật Post-processing [Bokeh, SSAO, GodRays, Sharpen, LensDirt]
                bokehPass.enabled = config.passes[0];
                ssaoPass.enabled = config.passes[1];
                godRaysPass.enabled = config.passes[2];
                sharpenPass.enabled = config.passes[3];
                lensDirtPass.enabled = config.passes[4];

                // 3. Cập nhật Geometry (Vật thể chính & Titan) - Nặng nhất
                // Dispose cũ
                torusKnot.geometry.dispose();
                titanMesh.geometry.dispose();
                
                // Tạo mới với độ phân giải tương ứng
                const newTorusGeo = new THREE.TorusKnotGeometry(10, 3, config.torus[0], config.torus[1]);
                torusKnot.geometry = newTorusGeo;
                wireframeMesh.geometry = newTorusGeo; // Cập nhật cả lớp vỏ wireframe

                const newTitanGeo = new THREE.TorusKnotGeometry(60, 2, config.titan[0], config.titan[1], 2, 5);
                titanMesh.geometry = newTitanGeo;

                // 4. Cập nhật Shadow Map Resolution
                const lights = [pointLight1, pointLight2, pointLight3];
                lights.forEach(light => {
                    if (config.shadow === 0) {
                        light.castShadow = false; // Tắt bóng đổ ở chế độ Super Low
                    } else {
                        light.castShadow = true;
                        light.shadow.mapSize.width = config.shadow;
                        light.shadow.mapSize.height = config.shadow;
                    }
                    
                    // Buộc renderer cập nhật shadow map (dispose map cũ)
                    if (light.shadow.map) {
                        light.shadow.map.dispose();
                        light.shadow.map = null;
                    }
                });

                // 5. Tối ưu Pixel Ratio cho Super Low
                if (level === 0) renderer.setPixelRatio(0.75); // Giảm độ phân giải render để mượt hơn
                else renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setSize(window.innerWidth, window.innerHeight); // Cập nhật lại kích thước

                console.log(`Đã chuyển sang Cấp độ ${level}`);
                sysLog(`Graphics Quality: Level ${level}`);
                
                // 3. Fade In (Hiện lại cảnh)
                overlay.style.opacity = 0;

                // 4. Tắt Warp sau khi đã hiện cảnh (tạo cảm giác giảm tốc khi đến nơi)
                setTimeout(() => {
                    isWarping = false;
                    if(warpBtn) warpBtn.classList.remove('active');
                    sysLog("HYPERSPACE JUMP COMPLETE");
                }, 800);

                }, 500);
            }, 800);
        };

        // --- TÍNH NĂNG MỚI: Screenshot (Phím P) ---
        function takeScreenshot() {
            const link = document.createElement('a');
            link.download = `quantum_benchmark_${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
            sysLog("Screenshot Saved");
        }
        document.getElementById('screenshot-btn').addEventListener('click', takeScreenshot);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') takeScreenshot();
        });

        // 7. Vòng lặp Animation
        let lastTime = Date.now();
        let accumulatedTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const now = Date.now();
            const dt = (now - lastTime) * 0.001;
            lastTime = now;

            // Vẽ Matrix Rain
            drawMatrixRain();

            // Xử lý hiệu ứng Warp
            const targetWarp = isWarping ? 1.0 : 0.0;
            warpFactor += (targetWarp - warpFactor) * 0.05; // Lerp mượt mà
            
            // Time Dilation (Slow Motion khi giữ chuột trái)
            const timeMultiplier = (isGravityActive === 1) ? 0.1 : 1.0;

            // Biến đổi thời gian dựa trên tốc độ Warp và Slow Mo
            const timeScale = (1 + warpFactor * 10) * timeMultiplier * manualTimeScale; 
            accumulatedTime += dt * 0.5 * timeScale;
            const time = accumulatedTime;
            
            // Xử lý Audio Data
            let bass = 0, mid = 0, high = 0;
            if (audioActive && analyser) {
                analyser.getByteFrequencyData(dataArray);
                // Lấy trung bình các dải tần
                const bassRange = dataArray.slice(0, 10);
                const midRange = dataArray.slice(10, 50);
                const highRange = dataArray.slice(50, 100);
                
                bass = bassRange.reduce((a, b) => a + b, 0) / bassRange.length / 255; // 0.0 - 1.0
                mid = midRange.reduce((a, b) => a + b, 0) / midRange.length / 255;
                high = highRange.reduce((a, b) => a + b, 0) / highRange.length / 255;

                // --- Trigger Audio Pulse on Bass Hit ---
                if (bass > 0.7 && (now - lastPulseTime) > pulseCooldown) {
                    // Sử dụng màu của đèn bass để tạo xung
                    spawnAudioPulse(pointLight1.color);
                    lastPulseTime = now;
                }
            }

            // Hiệu ứng Camera FOV (Kéo dãn không gian)
            const baseFov = 60;
            camera.fov = baseFov + warpFactor * 50; // FOV tăng từ 60 lên 110
            camera.updateProjectionMatrix();

            // Xoay vật thể chính
            torusKnot.rotation.x += 0.005 * timeScale;
            torusKnot.rotation.y += 0.005 * timeScale;

            // Animation cho Quantum Core
            quantumCore.rotation.y -= 0.02;
            quantumCore.rotation.z += 0.01;
            quantumCore.scale.setScalar(1 + Math.sin(time * 10) * 0.05 + bass * 0.5); // Rung động theo Bass

            // Animation cho Hologram Text
            holoGroup.rotation.y -= 0.005 * timeScale;
            holoGroup.position.y = Math.sin(time * 0.5) * 2; // Bay lên xuống nhẹ nhàng

            // Animation cho Glass Sphere
            glassSphere.rotation.y = -time * 0.1;
            glassSphere.rotation.z = time * 0.05;

            // Cập nhật Shader
            blobMat.uniforms.uTime.value = time;
            blob.rotation.y = time * 0.2;
            
            // Animation Black Hole
            if(isBlackHoleActive) {
                accretionDisk.rotation.z -= 0.1 * timeScale;
                const scale = 1 + Math.sin(time * 10) * 0.05;
                blackHoleMesh.scale.setScalar(scale);
            }

            // Animation cho Supernova
            if (supernovaActive) {
                supernovaTime += dt;
                const scale = 1 + supernovaTime * 150; // Nở ra rất nhanh
                supernovaMesh.scale.setScalar(scale);
                supernovaMat.opacity = Math.max(0, 1 - supernovaTime * 1.5);
                
                // Flash effect (Làm chói lòa ánh sáng)
                const flashIntensity = Math.max(0, 1 - supernovaTime) * 10;
                bloomPass.strength = 0.2 + flashIntensity; // Tăng độ sáng Bloom

                if (supernovaMat.opacity <= 0) {
                    supernovaActive = false;
                    supernovaMesh.visible = false;
                    bloomPass.strength = 0.2; // Reset Bloom
                }
            }

            // Animation cho Scanner
            if (isScanning) {
                scanTime += dt;
                scannerPass.uniforms.uTime.value = scanTime;
                if (scanTime > 1.5) { // Kết thúc quét (thời gian > 1.5s để chạy hết màn hình)
                    isScanning = false;
                    scannerPass.enabled = false;
                    sysLog("SCAN COMPLETE. NO ANOMALIES.");
                }
            }

            // Animation cho Digital Rain Material
            if(isRainActive) matrixObjMat.uniforms.uTime.value = time;

            // Cập nhật Reflection (Ẩn vật thể chính để không tự phản chiếu chính nó gây lỗi hình ảnh)
            torusKnot.visible = false;
            cubeCamera.update(renderer, scene);
            if(!isBlackHoleActive) torusKnot.visible = true;

            // Cập nhật Gravity Target (Vị trí chuột trong không gian 3D)
            gravityPlane.normal.copy(camera.position).normalize(); // Mặt phẳng luôn hướng về camera
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(gravityPlane, gravityTarget);

            // Animation cho Debris (Tính toán nặng mỗi khung hình)
            for (let i = 0; i < debrisCount; i++) {
                const data = debrisData[i];
                
                // --- Xử lý Vật lý Gravity ---
                if (isGravityActive !== 0 && gravityTarget) {
                    // Tính khoảng cách từ mảnh vỡ đến con trỏ chuột
                    const currentPos = data.initialPos.clone().add(data.physicsPos);
                    const dist = gravityTarget.distanceTo(currentPos);
                    
                    // Tính vector lực (Hút hoặc Đẩy)
                    const forceDir = new THREE.Vector3().subVectors(gravityTarget, currentPos).normalize();
                    const force = (5.0 * isGravityActive) / (1 + dist * 0.1); // Lực mạnh hơn khi ở gần
                    
                    data.velocity.add(forceDir.multiplyScalar(force));
                }
                
                // --- Xử lý Black Hole Physics ---
                if (isBlackHoleActive) {
                    const currentPos = data.initialPos.clone().add(data.physicsPos);
                    const dist = currentPos.length();
                    
                    if (dist > 10) { // Hút về tâm (0,0,0)
                        const forceDir = currentPos.normalize().negate();
                        const force = 10.0 / (1 + dist * 0.01); // Lực hút cực mạnh
                        data.velocity.add(forceDir.multiplyScalar(force));
                        
                        // Tạo xoáy (Swirl)
                        const swirlDir = new THREE.Vector3(-currentPos.z, 0, currentPos.x).normalize();
                        data.velocity.add(swirlDir.multiplyScalar(force * 0.5));
                    }
                }

                // Lực đàn hồi (Kéo về vị trí cũ)
                data.velocity.add(data.physicsPos.clone().multiplyScalar(-0.05));
                // Ma sát (Giảm tốc dần)
                data.velocity.multiplyScalar(0.95);
                // Cập nhật vị trí vật lý
                data.physicsPos.add(data.velocity);

                // Áp dụng vào vị trí hiển thị
                dummy.position.copy(data.initialPos).add(data.physicsPos);
                // Cộng thêm hiệu ứng sóng cũ
                dummy.position.y += Math.sin(time * 2 + data.offset) * 5;
                dummy.rotation.x += data.rotSpeed * timeScale;
                dummy.rotation.y += data.rotSpeed * timeScale;
                dummy.updateMatrix();
                debrisMesh.setMatrixAt(i, dummy.matrix);
            }
            debrisMesh.instanceMatrix.needsUpdate = true;

            // Animation cho Neural Lines (Kết nối các debris ngẫu nhiên)
            const positions = lineMesh.geometry.attributes.position.array;
            const v1 = new THREE.Vector3();
            const v2 = new THREE.Vector3();
            let lineIdx = 0;
            
            for(let i = 0; i < lineCount; i++) {
                const idx1 = i % debrisCount;
                const idx2 = (i + 500) % debrisCount; // Offset khác để nối xa hơn
                
                debrisMesh.getMatrixAt(idx1, dummy.matrix);
                v1.setFromMatrixPosition(dummy.matrix);
                
                debrisMesh.getMatrixAt(idx2, dummy.matrix);
                v2.setFromMatrixPosition(dummy.matrix);

                positions[lineIdx++] = v1.x; positions[lineIdx++] = v1.y; positions[lineIdx++] = v1.z;
                positions[lineIdx++] = v2.x; positions[lineIdx++] = v2.y; positions[lineIdx++] = v2.z;
            }
            lineMesh.geometry.attributes.position.needsUpdate = true;

            // Animation cho Menger Sponge
            spongeMesh.rotation.x += 0.001 * timeScale;
            spongeMesh.rotation.y += 0.001 * timeScale;

            // Animation cho Vortex
            for(let i=0; i<vortexCount; i++) {
                const data = vortexData[i];
                data.angle += data.speed * timeScale;
                const r = data.radius + Math.sin(time * 6 + i) * 2; // Giữ nhịp đập riêng (đồng bộ với time)
                vortexDummy.position.set(Math.cos(data.angle)*r, data.y, Math.sin(data.angle)*r);
                vortexDummy.rotation.x += 0.05;
                vortexDummy.rotation.z += 0.05;
                vortexDummy.updateMatrix();
                vortexMesh.setMatrixAt(i, vortexDummy.matrix);
            }
            vortexMesh.instanceMatrix.needsUpdate = true;

            // Animation cho Floor
            for(let i=0; i<floorSize; i++) {
                for(let j=0; j<floorSize; j++) {
                    const index = i * floorSize + j;
                    floorDummy.position.set((i - floorSize/2) * 5, 0, (j - floorSize/2) * 5);
                    const scaleY = 1 + Math.sin(time * 2 + i * 0.3 + j * 0.3) * 0.8;
                    floorDummy.scale.set(1, scaleY, 1);
                    floorDummy.updateMatrix();
                    floorMesh.setMatrixAt(index, floorDummy.matrix);
                }
            }
            floorMesh.instanceMatrix.needsUpdate = true;

            // Animation cho Satellites
            satellites.forEach(sat => {
                sat.userData.angle += sat.userData.speed * timeScale;
                sat.position.x = Math.cos(sat.userData.angle) * sat.userData.radius;
                sat.position.z = Math.sin(sat.userData.angle) * sat.userData.radius;
                sat.position.y = Math.sin(time + sat.userData.yOffset) * 10;
                sat.lookAt(0, 0, 0);
                sat.rotateZ(time);
            });

            // Animation cho Data Streams
            for(let i=0; i<streamCount; i++) {
                const data = streamData[i];
                data.t += data.speed * timeScale;
                if(data.t > 100) data.t = 0; // Reset khi lên đỉnh

                const angle = data.t * 0.5 + (data.branch * (Math.PI / 2)) + time * 0.2;
                const y = (data.t - 50) * 3;
                
                streamDummy.position.set(Math.cos(angle) * data.radius, y, Math.sin(angle) * data.radius);
                streamDummy.rotation.set(time, time, time);
                streamDummy.updateMatrix();
                streamMesh.setMatrixAt(i, streamDummy.matrix);
            }
            streamMesh.instanceMatrix.needsUpdate = true;

            // Animation cho Dyson Cage
            cageMesh.rotation.y += 0.0005 * timeScale;
            cageMesh.rotation.z += 0.0002 * timeScale;
            cageMesh2.rotation.y -= 0.0007 * timeScale;
            cageMesh2.rotation.x += 0.0005 * timeScale;

            // Animation cho Titan Structure
            titanMesh.rotation.x += 0.001 * timeScale;
            titanMesh.rotation.y -= 0.001 * timeScale;

            // Animation cho Volumetric Beams
            beamMat.uniforms.uTime.value = time;
            beamMesh.rotation.z += 0.002 * timeScale;
            beamMesh2.rotation.z -= 0.003 * timeScale;

            // Animation cho Nano Swarm (Tính toán vị trí cho 10,000 vật thể)
            for(let i=0; i<swarmCount; i++) {
                const data = swarmData[i];
                // Chuyển động sóng sin phức tạp
                const y = Math.sin(time * 2 + data.offset + data.x * 0.05) * 20 + Math.cos(time + data.z * 0.05) * 20;
                swarmDummy.position.set(data.x, y, data.z);
                swarmDummy.rotation.set(time + data.offset, time, 0);
                swarmDummy.updateMatrix();
                swarmMesh.setMatrixAt(i, swarmDummy.matrix);
            }
            swarmMesh.instanceMatrix.needsUpdate = true;

            // Animation cho Tunnel
            tunnel.rotation.y += 0.005 * timeScale;

            // Animation cho Volumetric Fog
            fogMat.uniforms.uTime.value = time;

            // Cập nhật vị trí nguồn sáng cho God Rays Pass
            // Chiếu vị trí của Quantum Core (0,0,0) lên màn hình 2D
            const corePos = new THREE.Vector3(0, 0, 0);
            corePos.project(camera);
            // Chuyển từ toạ độ clip space (-1 đến 1) sang UV space (0 đến 1)
            const x = (corePos.x + 1) / 2;
            const y = (corePos.y + 1) / 2;
            godRaysPass.uniforms.fX.value = x;
            godRaysPass.uniforms.fY.value = y;

            // Cập nhật tiêu cự cho Bokeh (tự động lấy nét vào tâm)
            bokehPass.uniforms['focus'].value = camera.position.length();

            // Hiệu ứng RGB Shift đập theo nhịp
            effectShift.uniforms['amount'].value = 0.0015 + (Math.sin(time * 5) * 0.001) + (warpFactor * 0.02) + (high * 0.01); // Tăng mạnh khi Warp và High freq

            // Animation cho các vòng nhẫn
            rings.forEach((ring, i) => {
                ring.rotation.x += 0.002 * (i + 1);
                ring.rotation.y += 0.002 * (i + 1);
            });

            // Animation cho tinh thể
            crystals.forEach(c => {
                c.mesh.rotation.x += c.speed;
                c.mesh.rotation.y += c.speed;
                c.mesh.position.y += Math.sin(time * 2 + c.offset) * 0.05; // Nhấp nhô nhẹ
            });

            // Di chuyển đèn xung quanh
            pointLight1.position.x = Math.sin(time * 0.7) * (30 + bass * 20); // Đèn di chuyển rộng hơn khi có bass
            pointLight1.position.y = Math.cos(time * 0.5) * 40;
            pointLight1.position.z = Math.cos(time * 0.3) * 30;

            pointLight2.position.x = Math.cos(time * 0.3) * 30;
            pointLight2.position.y = Math.sin(time * 0.5) * 40;
            pointLight2.position.z = Math.sin(time * 0.7) * (30 + mid * 20);

            // Xoay nhẹ hệ thống hạt
            particlesMesh.rotation.y -= 0.001 * timeScale;
            
            // Hiệu ứng Star Streak (Kéo dài ngôi sao khi Warp)
            // Kéo dài trục Z và hướng nó về phía camera để tạo hiệu ứng bay xuyên qua
            particlesMesh.scale.z = 1 + warpFactor * 50; 

            // Animation cho Shockwave
            if (shockwaveActive) {
                shockwaveTimer += dt;
                const scale = 1 + shockwaveTimer * 30; // Lan tỏa nhanh
                shockwaveMesh.scale.setScalar(scale);
                shockwaveMesh.lookAt(camera.position); // Luôn hướng về camera
                shockwaveMat.opacity = Math.max(0, 1 - shockwaveTimer * 2); // Mờ dần nhanh
                
                if (shockwaveMat.opacity <= 0) {
                    shockwaveActive = false;
                    shockwaveMesh.visible = false;
                }
            }

            // Animation cho Energy Pulses
            for (let i = audioPulses.length - 1; i >= 0; i--) {
                const pulse = audioPulses[i];
                const maxLife = 2000; // 2 giây
                const elapsed = now - pulse.startTime;
                const progress = elapsed / maxLife;

                if (progress >= 1) {
                    pulseGroup.remove(pulse.mesh);
                    pulse.mesh.geometry.dispose();
                    pulse.mesh.material.dispose();
                    audioPulses.splice(i, 1);
                } else {
                    const scale = 1 + progress * 100; // Lan rộng tới bán kính 100
                    pulse.mesh.scale.setScalar(scale);
                    pulse.mesh.material.opacity = 0.8 * (1 - Math.pow(progress, 2)); // Mờ dần (ease-out)
                    pulse.mesh.lookAt(camera.position); // Luôn hướng về camera
                }
            }

            if (isDirectorMode) {
                updateDirector();
            } else {
                controls.update(); // Cập nhật controls thủ công
            }
            
            // Logic Benchmark
            if(isBenchmarking) {
                benchFrames++;
                benchFrameTimes.push(dt);
                const elapsed = performance.now() - benchStartTime;
                if(elapsed >= 10000) { // Chạy trong 10 giây
                    finishBenchmark(elapsed);
                }
            }

            // Random System Logs (Tạo cảm giác hệ thống đang hoạt động ngầm)
            if (Math.random() < 0.002) {
                const msgs = ["Optimizing Shaders...", "Garbage Collection...", "Syncing Particles...", "Ping: 1ms", "Vortex Stable"];
                sysLog(msgs[Math.floor(Math.random() * msgs.length)]);
            }

            stats.update();    // Cập nhật FPS
            statsMem.update(); // Cập nhật Memory
            // renderer.render(scene, camera); // Thay thế bằng composer để có hiệu ứng Bloom
            composer.render();
        }

        // 8. Xử lý khi thay đổi kích thước cửa sổ
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            sharpenPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight); // Cập nhật resolution cho Sharpen
            
            // Resize Matrix Rain
            matrixCanvas.width = window.innerWidth;
            matrixCanvas.height = window.innerHeight;
            matrixContext.fillStyle = '#000';
            matrixContext.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
            matrixColumns = Math.floor(window.innerWidth / matrixFontSize);
            for(let i = 0; i < matrixColumns; i++) {
                if(!matrixDrops[i]) matrixDrops[i] = 1;
            }

            // Cập nhật thông tin độ phân giải trong GPU Info
            const gpuDiv = document.getElementById('gpu-info');
            if(gpuDiv) gpuDiv.innerHTML = `GPU: ${rendererInfo}<br>Res: ${window.innerWidth}x${window.innerHeight}`;
        }

        animate();
    </script>
</body>
</html>